

import customtkinter as ctk
import tkinter as tk
from tkinter import messagebox
import socket
import threading
import time
import os
import io
import json
import shutil
import random
import re
import sys
from datetime import datetime, timedelta, date
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple

import pyautogui
from PIL import Image, ImageTk

import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.animation as animation
# ‚úÖ TAREAS
# ‚úÖ TAREAS (m√≥dulo compartido)
from tasks_module import TasksModule, DEFAULT_THEME


DEFAULT_HOST = os.getenv("KONTROL_SERVER_HOST", "185.254.207.202")
try:
    DEFAULT_PORT = int(os.getenv("KONTROL_SERVER_PORT", "5555"))
except ValueError:
    DEFAULT_PORT = 5555
# ----------------------------
# Theme / Colors
# ----------------------------
ctk.set_appearance_mode("Dark")

TURQ = "#19d3c5"
NAVY = "#0b1b2b"
WHITE = "#ffffff"
CARD = "#142235"
CARD2 = "#101a2a"
MUTED = "#9aa7b3"
DANGER = "#e74c3c"
OK = "#2ecc71"
WARN = "#f1c40f"

APP_W = 1400
APP_H = 860

# ----------------------------
# DISTRACTION LIST
# ----------------------------
DISTRACTION_KEYWORDS = [
    "facebook","instagram","threads","tiktok","twitter","x.com","snapchat","reddit","9gag",
    "discord","whatsapp web","telegram","messenger","signal","line","kik","skype","wechat",
    "tinder","bumble","hinge","badoo","grindr","meetup",
    "youtube","youtube studio","twitch","netflix","prime video","amazon prime video","hbo","hbo max","max.com",
    "disney+","disney plus","apple tv","apple tv+","hulu","paramount+","paramount plus","peacock","crunchyroll",
    "pluto tv","rakuten tv","movistar plus","atresplayer","mitele","rtve play","vimeo","dailymotion",
    "spotify","soundcloud","deezer","apple music","tidal","pandora","iheart","tunein",
    "steam","epic games","epic games launcher","battle.net","blizzard","riot client","league of legends",
    "valorant","fortnite","roblox","minecraft","gta","grand theft auto","call of duty","warzone",
    "counter-strike","cs2","dota","overwatch","apex","pubg","genshin","honkai","runescape",
    "origin","ea app","ubisoft connect","gog","itch.io","xbox","xbox app","playstation","psn","nintendo",
    "amazon","amazon.com","aliexpress","temu","shein","zalando","asos","ebay","etsy","wallapop","vinted",
    "elcorteingles","zara","bershka","pull&bear","stradivarius","mango","hm.com","h&m","uniqlo",
    "nike","adidas","under armour","puma","decathlon","ikea","mediamarkt","fnac","carrefour","lidl",
    "buzzfeed","tmz","people.com","hola","lecturas","semana","el espa√±ol","marca","as.com","sport.es",
    "goal.com","bleacher report","espn","fox sports","cnn","bbc","elpais","elmundo","20minutos",
    "bet365","bwin","william hill","betfair","pokerstars","888poker","codere","sportium","betway",
    "draftkings","fanduel",
    "quora","imgur","giphy","tenor","memes","lifehacker",
]

# ----------------------------
# Helpers: appdata dirs
# ----------------------------
def get_appdata_base_dir() -> str:
    base = os.getenv("APPDATA") or os.path.expanduser("~")
    folder = os.path.join(base, "CSDViajes", "KClient")
    os.makedirs(folder, exist_ok=True)
    return folder

def get_cache_dir() -> str:
    cache = os.path.join(get_appdata_base_dir(), "cache_capturas")
    os.makedirs(cache, exist_ok=True)
    return cache

def cred_file_path() -> str:
    return os.path.join(get_appdata_base_dir(), "credenciales.txt")
def users_cache_path() -> str:
    return os.path.join(get_appdata_base_dir(), "users_cache.json")

# ----------------------------
# Normalize window titles
# ----------------------------
def normalize_app_name(window_title: str) -> str:
    t = (window_title or "").strip()
    if not t:
        return "Sistema"

    low = t.lower()
    browsers = [
        ("google chrome", "Chrome"),
        ("microsoft edge", "Edge"),
        ("brave", "Brave"),
        ("mozilla firefox", "Firefox"),
        ("opera", "Opera"),
    ]
    for key, label in browsers:
        if key in low:
            if " - " in t:
                parts = t.split(" - ")
                last = parts[-1].strip().lower()
                tab_title = " - ".join(parts[:-1]).strip() if key in last else parts[0].strip()
            else:
                tab_title = t
            tab_title = tab_title.replace("\n", " ").strip()
            if not tab_title or tab_title.lower() == key:
                tab_title = "Nueva pesta√±a"
            if len(tab_title) > 80:
                tab_title = tab_title[:80] + "‚Ä¶"
            return f"{label} | {tab_title}"

    if " - " in t:
        last = t.split(" - ")[-1].strip()
        if last:
            return last[:60]
    return t[:60]

# ----------------------------
# ActivityTracker (FG/BG -> JSON deltas)
# ----------------------------
class ActivityTracker:
    def __init__(self, send_func, username: str, interval_send=10.0):
        self.send_func = send_func
        self.username = username
        self.interval_send = interval_send
        self.last_tick = time.time()
        self.last_send = time.time()
        self.last_fg_app = None
        self.acc: Dict[str, Dict[str, float]] = {}


    def _bump(self, app, fg=0.0, bg=0.0):
        if not app:
            app = "Sistema"
        if app not in self.acc:
            self.acc[app] = {"fg": 0.0, "bg": 0.0}
        self.acc[app]["fg"] += fg
        self.acc[app]["bg"] += bg

    def tick(self, fg_title: str, others_titles: List[str]):
        now = time.time()
        dt = max(0.0, now - self.last_tick)
        self.last_tick = now

        fg_app = normalize_app_name(fg_title)
        bg_apps = set(normalize_app_name(t) for t in (others_titles or []) if t and str(t).strip())
        if fg_app in bg_apps:
            bg_apps.remove(fg_app)

        if fg_app:
            self._bump(fg_app, fg=dt)
        for a in bg_apps:
            self._bump(a, bg=dt)

        foco_cambio = (fg_app != self.last_fg_app)
        tiempo_envio = (now - self.last_send) >= self.interval_send

        self.last_fg_app = fg_app

        if foco_cambio or tiempo_envio:
            self.flush()

    def flush(self):
        if not self.acc:
            return
        payload = {"type": "activity_v2", "user": self.username, "ts": int(time.time()), "delta": self.acc}
        try:
            self.send_func(payload)
            self.acc = {}
            self.last_send = time.time()
        except Exception as e:
            print(f"[ActivityTracker] Error enviando: {e}")

# ----------------------------
# UI helpers
# ----------------------------
class GradientCanvas(tk.Canvas):
    def __init__(self, master, color1: str, color2: str, animate: bool = False, **kwargs):
        super().__init__(master, highlightthickness=0, **kwargs)
        self.color1 = color1
        self.color2 = color2
        self.animate = animate
        self._phase = 0.0
        self._job = None
        self.bind("<Configure>", lambda e: self.draw_gradient())
        if self.animate:
            self._start_anim()

    @staticmethod
    def _hex_to_rgb(h: str):
        h = h.lstrip("#")
        return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

    @staticmethod
    def _rgb_to_hex(rgb):
        return "#%02x%02x%02x" % rgb

    def draw_gradient(self):
        self.delete("grad")
        w = self.winfo_width()
        h = self.winfo_height()
        if w <= 1 or h <= 1:
            return

        c1 = self.color1
        c2 = self.color2
        if self.animate:
            import math
            t = (1 + math.sin(self._phase)) / 2
            def tween(ca, cb, tt):
                ra, ga, ba = self._hex_to_rgb(ca)
                rb, gb, bb = self._hex_to_rgb(cb)
                return self._rgb_to_hex((
                    int(ra + (rb - ra) * tt),
                    int(ga + (gb - ga) * tt),
                    int(ba + (bb - ba) * tt),
                ))
            c1 = tween(self.color1, "#0b3550", 0.18 * t)
            c2 = tween(self.color2, "#051018", 0.14 * (1 - t))

        r1, g1, b1 = self._hex_to_rgb(c1)
        r2, g2, b2 = self._hex_to_rgb(c2)
        steps = max(h, 220)

        for i in range(steps):
            tt = i / (steps - 1)
            r = int(r1 + (r2 - r1) * tt)
            g = int(g1 + (g2 - g1) * tt)
            b = int(b1 + (b2 - b1) * tt)
            y1 = int(h * (i / steps))
            y2 = int(h * ((i + 1) / steps))
            self.create_rectangle(0, y1, w, y2, fill=self._rgb_to_hex((r, g, b)),
                                  outline="", tags="grad")

    def _start_anim(self):
        def tick():
            self._phase += 0.08
            self.draw_gradient()
            self._job = self.after(50, tick)
        tick()

class WindowChrome(ctk.CTkFrame):
    def __init__(self, master, title_left: str, wifi_text: str = "Wi-Fi: --", on_close=None):
        super().__init__(master, fg_color="transparent", height=44)
        self.on_close = on_close
        self.pack_propagate(False)  # ‚úÖ NO agrandar por contenido

        left = ctk.CTkFrame(self, fg_color="transparent")
        left.pack(side="left", padx=12, pady=0)

        self.lbl_title = ctk.CTkLabel(left, text=title_left, text_color=WHITE, font=("Roboto", 14, "bold"))
        self.lbl_title.pack(side="left", pady=0)

        self.lbl_wifi = ctk.CTkLabel(left, text=f"   {wifi_text}", text_color=MUTED, font=("Roboto", 11))
        self.lbl_wifi.pack(side="left", padx=(8, 0), pady=0)

        right = ctk.CTkFrame(self, fg_color="transparent")
        right.pack(side="right", padx=10, pady=0)
    def set_wifi(self, text: str):
        self.lbl_wifi.configure(text=f"   {text}")

    def _toggle_fullscreen(self):
        top = self.winfo_toplevel()
        self._fullscreen = not self._fullscreen
        top.attributes("-fullscreen", self._fullscreen)

    def _close(self):
        if self.on_close:
            self.on_close()
        else:
            self.winfo_toplevel().destroy()


    def set_wifi(self, text: str):
        self.lbl_wifi.configure(text=f"   {text}")

    def _toggle_fullscreen(self):
        top = self.winfo_toplevel()
        self._fullscreen = not self._fullscreen
        top.attributes("-fullscreen", self._fullscreen)

    def _close(self):
        if self.on_close:
            self.on_close()
        else:
            self.winfo_toplevel().destroy()

class IconNavButton(ctk.CTkButton):
    def __init__(self, master, text, emoji, command):
        super().__init__(master,
                         text=f"{emoji}  {text}",
                         anchor="w",
                         height=42,
                         fg_color="transparent",
                         hover_color="#1e3350",
                         text_color=WHITE,
                         font=("Roboto", 13),
                         command=command)
class EmployeesPanel(ctk.CTkFrame):
    """
    Panel izquierda del Dashboard:
    - recibe lista de usuarios desde server (USER_LIST|a,b,c)
    - crea mini-cards por usuario (reutiliza si ya existe)
    - permite seleccionar uno para mostrar en 'Detalle de empleado'
    """
    def __init__(self, master, on_select_user=None):
        super().__init__(master, fg_color="transparent")
        self.on_select_user = on_select_user

        self.users: List[str] = []
        self.cards: Dict[str, ctk.CTkFrame] = {}
        self.status: Dict[str, str] = {}  # "online"/"offline"/etc (si luego lo us√°s)

        # T√≠tulo
        head = ctk.CTkFrame(self, fg_color="transparent")
        head.pack(fill="x", pady=(0, 8))
        ctk.CTkLabel(head, text="Empleados", font=("Roboto", 14, "bold")).pack(side="left")

        self.btn_refresh = ctk.CTkButton(head, text="Actualizar ‚ü≥", width=120)
        self.btn_refresh.pack(side="right")

        # Scroll
        self.scroll = ctk.CTkScrollableFrame(self, fg_color="transparent", height=340)
        self.scroll.pack(fill="both", expand=True)

    def set_refresh_command(self, cmd):
        self.btn_refresh.configure(command=cmd)

    def update_users(self, users: List[str]):
        # Normalizar / limpiar
        users = [u.strip() for u in (users or []) if u and u.strip()]
        # opcional: ordenar (si quer√©s mantener el orden del server, coment√° la l√≠nea)
        # users.sort(key=lambda x: x.lower())

        self.users = users

        alive = set(users)
        # borrar cards que ya no existen
        for name in list(self.cards.keys()):
            if name not in alive:
                try:
                    self.cards[name].destroy()
                except:
                    pass
                del self.cards[name]

        # crear / actualizar cards
        for name in users:
            if name not in self.cards:
                self.cards[name] = self._create_card(name)

        # re-pack en orden
        for w in self.scroll.winfo_children():
            w.pack_forget()
        for name in users:
            self.cards[name].pack(fill="x", padx=6, pady=6)

    def set_user_status(self, user: str, status_text: str, color: str = OK):
        """
        Si luego te llega USER_STATS, pod√©s llamar esto para pintar cada card.
        """
        if user not in self.cards:
            return
        card = self.cards[user]
        # buscamos labels guardadas
        lbl_status = getattr(card, "_lbl_status", None)
        dot = getattr(card, "_dot", None)
        if lbl_status:
            lbl_status.configure(text=status_text, text_color=color)
        if dot:
            dot.configure(text="‚óè", text_color=color)

    def _create_card(self, name: str) -> ctk.CTkFrame:
        card = ctk.CTkFrame(self.scroll, fg_color=CARD2, corner_radius=16)
        card.pack(fill="x", padx=6, pady=6)

        row = ctk.CTkFrame(card, fg_color="transparent")
        row.pack(fill="x", padx=12, pady=10)

        dot = ctk.CTkLabel(row, text="‚óè", text_color=MUTED, font=("Roboto", 14, "bold"))
        dot.pack(side="left")

        lbl_name = ctk.CTkLabel(row, text=name, font=("Roboto", 13, "bold"))
        lbl_name.pack(side="left", padx=(10, 0))

        lbl_status = ctk.CTkLabel(row, text="‚Äî", text_color=MUTED, font=("Roboto", 11))
        lbl_status.pack(side="right")

        # guardar refs para actualizar status luego
        card._dot = dot
        card._lbl_status = lbl_status

        def on_click(_evt=None, uname=name):
            if self.on_select_user:
                self.on_select_user(uname)

        # clickable: bind a frame y labels
        card.bind("<Button-1>", on_click)
        row.bind("<Button-1>", on_click)
        lbl_name.bind("<Button-1>", on_click)
        lbl_status.bind("<Button-1>", on_click)
        dot.bind("<Button-1>", on_click)

        return card

# ----------------------------
# ConsoleWindow (remoto)
# ----------------------------
class ConsoleWindow(ctk.CTkFrame):
    def __init__(self, master, sock, socket_lock: threading.Lock):
        super().__init__(master, fg_color=NAVY)
        self.sock = sock
        self.socket_lock = socket_lock

        title = ctk.CTkLabel(self, text="Consola remota", font=("Roboto", 16, "bold"))
        title.pack(anchor="w", padx=16, pady=(14, 6))

        self.output = ctk.CTkTextbox(self, fg_color="#000000", text_color="#00ff00", font=("Consolas", 12))
        self.output.pack(fill="both", expand=True, padx=16, pady=(0, 12))
        self.output.insert("end", "--- CONSOLA CONECTADA ---\nhelp para comandos\n\n")
        self.output.configure(state="disabled")

        bottom = ctk.CTkFrame(self, fg_color="transparent")
        bottom.pack(fill="x", padx=16, pady=(0, 16))

        self.entry = ctk.CTkEntry(bottom, placeholder_text="Comando...", fg_color=CARD)
        self.entry.pack(side="left", fill="x", expand=True, padx=(0, 10))
        self.entry.bind("<Return>", self._send)

        ctk.CTkButton(bottom, text="Enviar", width=120, fg_color=TURQ, text_color="#001013",
                      hover_color="#12b5aa", command=self._send).pack(side="left")

    def add_output(self, text: str):
        self.output.configure(state="normal")
        self.output.insert("end", text)
        self.output.configure(state="disabled")
        self.output.see("end")

    def _send(self, _evt=None):
        cmd = self.entry.get().strip()
        if not cmd:
            return

        if cmd.lower() == "help":
            self.add_output(
                "\n--- COMANDOS ---\n"
                "online\nlist\nkick [user]\nadd [u] [p]\nsetrole [u] [r]\nmsg [u] [texto]\n"
                "history [user]\nroles\nhistorial\nreset_capturas\nexit\n\n"
            )
            self.entry.delete(0, "end")
            return

        try:
            with self.socket_lock:
                self.sock.sendall(f"CMD_REMOTE|{cmd}".encode("utf-8"))
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo enviar: {e}")
        self.entry.delete(0, "end")

# ----------------------------
# Screenshot gallery (cloud + cache)
# ----------------------------
# ----------------------------
# Screenshot gallery (cloud + cache) ‚úÖ FIXED/ROBUST
# ----------------------------
class ScreenshotGallery(ctk.CTkFrame):
    def __init__(self, master, sock, socket_lock: threading.Lock):
        super().__init__(master, fg_color=NAVY)
        self.sock = sock
        self.socket_lock = socket_lock

        self.cache_path = get_cache_dir()
        os.makedirs(self.cache_path, exist_ok=True)

        self._gen = 0
        self._download_req_ts = {}
        self._throttle_sec = 3.0

        self.all_filenames = []
        self.server_filenames = []
        self.local_filenames = []

        # Header
        top = ctk.CTkFrame(self, fg_color=CARD, corner_radius=16)
        top.pack(fill="x", padx=16, pady=(16, 12))

        ctk.CTkLabel(top, text="üì∑ Galer√≠a Cloud (sincronizada)", font=("Roboto", 16, "bold")).pack(
            side="left", padx=12, pady=10
        )

        self.filter_var = ctk.StringVar(value="Recientes")
        self.filter_menu = ctk.CTkOptionMenu(
            top, values=["Recientes", "Abecedario (Usuario)"],
            variable=self.filter_var, command=lambda _: self.apply_filter()
        )
        self.filter_menu.pack(side="left", padx=10)

        self.name_entry = ctk.CTkEntry(top, placeholder_text="Filtrar por usuario...", width=220, fg_color=CARD2)
        self.name_entry.pack(side="left", padx=10)

        ctk.CTkButton(top, text="Buscar", width=90, command=self.apply_filter).pack(side="left", padx=8)

        ctk.CTkButton(top, text="Sincronizar ‚òÅ", width=130, fg_color=OK, command=self.sync_with_server) \
            .pack(side="right", padx=10)

        ctk.CTkButton(top, text="Borrar cach√© üóë", width=140, fg_color="#c0392b",
                      hover_color="#a93226", command=self.clear_cache).pack(side="right", padx=10)

        # Status
        status = ctk.CTkFrame(self, fg_color="transparent")
        status.pack(fill="x", padx=16, pady=(0, 8))
        self.lbl_status = ctk.CTkLabel(status, text="Estado: ‚Äî", text_color=MUTED, font=("Roboto", 11))
        self.lbl_status.pack(anchor="w")

        self.scroll = ctk.CTkScrollableFrame(self, fg_color="transparent")
        self.scroll.pack(fill="both", expand=True, padx=16, pady=(0, 16))

        # Primer paint local + sync
        self.load_local_filenames()
        self.sync_with_server()

    # PEG√ÅS AQU√ç TODO tu c√≥digo de ScreenshotGallery:
    # _set_status, load_local_filenames, update_and_sync, apply_filter, _smart_load, etc.
    # (sin tocar la l√≥gica, solo adaptando lo que era Toplevel)


    # ----------------------------
    # UI safety helpers (gen-aware)
    # ----------------------------
    def _set_status(self, text: str, gen: Optional[int] = None):
        try:
            if gen is None:
                gen = getattr(self, "_gen", 0)
            if getattr(self, "_gen", None) != gen:
                return
            if self.lbl_status and self.lbl_status.winfo_exists():
                self.lbl_status.configure(text=f"Estado: {text}")
        except Exception:
            pass

    def _set_img_safe(self, lbl, img_tk, gen: int):
        try:
            if getattr(self, "_gen", None) != gen:
                return
            if not lbl or not lbl.winfo_exists():
                return
            lbl.configure(image=img_tk, text="")
            lbl.image = img_tk
        except tk.TclError:
            return

    def _set_text_safe(self, lbl, text: str, gen: int):
        try:
            if getattr(self, "_gen", None) != gen:
                return
            if not lbl or not lbl.winfo_exists():
                return
            lbl.configure(text=text)
        except Exception:
            return

    # ----------------------------
    # Lifecycle
    # ----------------------------
    def on_close(self):
        self._gen = getattr(self, "_gen", 0) + 1
        self.destroy()

    # ----------------------------
    # Cache management
    # ----------------------------
    def clear_cache(self):
        try:
            count = 0
            for f in os.listdir(self.cache_path):
                p = os.path.join(self.cache_path, f)
                if os.path.isfile(p) and f.lower().endswith((".jpg", ".jpeg", ".png")):
                    try:
                        os.remove(p)
                        count += 1
                    except:
                        pass
            messagebox.showinfo("OK", f"Cach√© limpiada ({count} capturas).")
            self.load_local_filenames()
            self.apply_filter()
        except Exception as e:
            messagebox.showerror("Error", str(e))

    # ----------------------------
    # Sync logic
    # ----------------------------
    def sync_with_server(self):
        # ‚úÖ invalida callbacks viejos (thumbnails que estaban por aplicarse)
        self._gen = getattr(self, "_gen", 0) + 1
        gen = self._gen
        self._set_status("Pidiendo lista al servidor‚Ä¶", gen)

        def task(local_gen=gen):
            try:
                with self.socket_lock:
                    # muy importante el \n
                    self.sock.sendall(b"GET_SCREENSHOT_LIST\n")
                # mientras llega SCREENSHOT_LIST, mostramos lo local
                self.load_local_filenames(local_gen)

                # Si el server tarda, igual no queda ‚Äúen blanco‚Äù
                self.after(0, lambda g=local_gen: self._set_status("Esperando SCREENSHOT_LIST‚Ä¶", g))
            except Exception as e:
                print("sync error:", e)
                self.after(0, lambda g=local_gen: self._set_status(f"Error sync: {e}", g))

        threading.Thread(target=task, daemon=True).start()

    def load_local_filenames(self, gen: Optional[int] = None):
        if gen is None:
            gen = getattr(self, "_gen", 0)
        try:
            files = [f for f in os.listdir(self.cache_path) if f.lower().endswith((".jpg", ".jpeg", ".png"))]
            self.local_filenames = files

            # merge conservador
            merged = set(self.all_filenames)
            merged.update(files)
            self.all_filenames = list(merged)

            # status
            self.after(0, lambda g=gen: self._set_status(
                f"Local: {len(files)} ‚Ä¢ Server: {len(self.server_filenames)} ‚Ä¢ Total: {len(self.all_filenames)}",
                g
            ))

            self.after(0, self.apply_filter)
        except Exception as e:
            print("load_local_filenames:", e)

    def update_and_sync(self, server_files: List[str]):

        """
        Llamada por tu listen_loop cuando llega: SCREENSHOT_LIST|a,b,c
        """
        self._gen = getattr(self, "_gen", 0) + 1
        gen = self._gen

        self.server_filenames = server_files[:] if server_files else []

        # merge server + local
        local_set = set(self.local_filenames or [])
        merged = set(local_set)
        merged.update(self.server_filenames)
        self.all_filenames = list(merged)

        self.after(0, lambda g=gen: self._set_status(
            f"Lista recibida ‚Ä¢ Local: {len(local_set)} ‚Ä¢ Server: {len(self.server_filenames)} ‚Ä¢ Total: {len(self.all_filenames)}",
            g
        ))
        self.after(0, self.apply_filter)

        # Pedir faltantes (SYNC_CHECK) para que el server empuje PHOTO_DATA
        try:

            missing = [f for f in self.server_filenames if f not in local_set]
            if missing:
                with self.socket_lock:
                    self.sock.sendall(("SYNC_CHECK|" + ",".join(missing) + "\n").encode("utf-8"))
                # nota: el guardado real depende de que tu receiver maneje PHOTO_DATA
        except Exception as e:
            print("update_and_sync:", e)

    # ----------------------------
    # Parsing filenames (robusto)
    # ----------------------------
    def _parse_filename(self, f: str) -> Tuple[str, datetime]:
        now = datetime.now()
        base = re.sub(r"\.(jpg|jpeg|png)$", "", f, flags=re.I)

        # ‚úÖ NUEVO: user_tag_YYYYMMDD_HHMMSS  (ej: Angelo_MANUAL_20260124_221321)
        m = re.search(r"^([A-Za-z0-9\-]+)_([A-Za-z0-9\-]+)_(\d{8})_(\d{6})$", base)
        if m:
            user = m.group(1)  # üëà ahora el user es el primero
            dt = self._safe_dt(m.group(3), m.group(4), now)
            return user, dt

        # (tu caso viejo lo pod√©s dejar, pero OJO: este regex es igual al de arriba,
        # as√≠ que si lo dej√°s tal cual, nunca se va a usar. Mejor reemplazarlo por completo.)

        # 2) user_YYYYMMDD_HHMMSS
        m = re.search(r"^([A-Za-z0-9\-]+)_(\d{8})_(\d{6})$", base)
        if m:
            user = m.group(1)
            dt = self._safe_dt(m.group(2), m.group(3), now)
            return user, dt

        m = re.search(r"(\d{8})[_\-]?(\d{6})", base)
        user = "Desconocido"
        if m:
            dt = self._safe_dt(m.group(1), m.group(2), now)
            return user, dt

        return user, now

    @staticmethod
    def _safe_dt(ymd: str, hms: str, fallback: datetime) -> datetime:
        try:
            return datetime.strptime(ymd + hms, "%Y%m%d%H%M%S")
        except:
            return fallback

    # ----------------------------
    # Filtering + render
    # ----------------------------
    def apply_filter(self, *_):
        # invalidate pending thumb callbacks
        gen = getattr(self, "_gen", 0)

        for w in self.scroll.winfo_children():
            w.destroy()

        target = (self.name_entry.get() or "").strip().lower()
        parsed: List[Tuple[str, str, datetime]] = []

        for f in (self.all_filenames or []):
            user, dt = self._parse_filename(f)
            if target and target not in user.lower():
                continue
            parsed.append((f, user, dt))

        if not parsed:
            empty = ctk.CTkFrame(self.scroll, fg_color=CARD, corner_radius=16)
            empty.pack(fill="x", padx=6, pady=8)
            ctk.CTkLabel(
                empty,
                text="No hay capturas para mostrar (todav√≠a).\nTip: toc√° 'Sincronizar ‚òÅ' y verific√° que llegue SCREENSHOT_LIST.",
                text_color=MUTED,
                justify="left"
            ).pack(padx=16, pady=16)
            return

        if self.filter_var.get() == "Recientes":
            parsed.sort(key=lambda x: x[2], reverse=True)
        else:
            parsed.sort(key=lambda x: x[1].lower())

        for fname, user, dt in parsed:
            self._add_item(fname, user, dt, gen)

    def _add_item(self, filename: str, user: str, dt: datetime, gen: int):
        box = ctk.CTkFrame(self.scroll, fg_color=CARD, corner_radius=16)
        box.pack(fill="x", padx=6, pady=8)

        head = ctk.CTkFrame(box, fg_color="transparent")
        head.pack(fill="x", padx=12, pady=(10, 6))

        ctk.CTkLabel(
            head,
            text=f"üë§ {user}   üìÖ {dt.strftime('%d/%m/%Y')}   ‚è± {dt.strftime('%H:%M:%S')}",
            text_color=WARN,
            font=("Roboto", 12, "bold")
        ).pack(side="left")

        local_path = os.path.join(self.cache_path, filename)

        ctk.CTkButton(
            head,
            text="Guardar üì•",
            width=120,
            fg_color=OK,
            command=lambda p=local_path, f=filename: self._copy_to_downloads(p, f)
        ).pack(side="right")

        lbl = tk.Label(box, text="Cargando‚Ä¶", fg="white", bg=CARD)
        lbl.pack(padx=12, pady=(0, 12))

        threading.Thread(target=self._smart_load, args=(filename, local_path, lbl, gen), daemon=True).start()

    def _copy_to_downloads(self, local_path, filename):
        if not os.path.exists(local_path):
            messagebox.showerror("Error", "La imagen a√∫n no est√° descargada.")
            return
        try:
            downloads = os.path.join(os.path.expanduser("~"), "Downloads")
            shutil.copy2(local_path, os.path.join(downloads, filename))
            messagebox.showinfo("OK", f"Copiada a Descargas:\n{filename}")
        except Exception as e:
            messagebox.showerror("Error", str(e))

    # ----------------------------
    # Thumbnail loading + requesting
    # ----------------------------
    def _throttle_ok(self, filename: str) -> bool:
        now = time.time()
        last = self._download_req_ts.get(filename, 0.0)
        if (now - last) < self._throttle_sec:
            return False
        self._download_req_ts[filename] = now
        return True

    def _smart_load(self, filename: str, local_path: str, lbl_widget, gen: int):
        """
        - Si existe en cach√©: carga y muestra.
        - Si no existe: pide DOWNLOAD_PHOTO (throttled) y espera estabilidad; si no llega, deja texto y no rompe.
        """
        try:
            # 0) si ya cerraron / cambi√≥ generaci√≥n
            if getattr(self, "_gen", None) != gen:
                return

            # 1) si no est√° en cach√©, pedirlo (throttle)
            if not os.path.exists(local_path):
                if self._throttle_ok(filename):
                    try:
                        with self.socket_lock:
                            self.sock.sendall(f"DOWNLOAD_PHOTO|{filename}\n".encode("utf-8"))
                    except Exception as e:
                        self.after(0, lambda lw=lbl_widget, g=gen: self._set_text_safe(lw, f"Error pidiendo foto: {e}", g))
                        return

                # 2) esperar a que aparezca y se estabilice
                if not self.wait_file_stable(local_path, checks=6, delay=0.25):
                    # no lleg√≥: mostrar estado (sin crash)
                    self.after(0, lambda lw=lbl_widget, g=gen: self._set_text_safe(
                        lw, "Pendiente de descarga‚Ä¶ (si no baja, revis√° PHOTO_DATA en listen_loop)", g
                    ))
                    return

            # 3) cargar imagen
            try:
                img = Image.open(local_path)
                img.load()
            except Exception:
                self.after(0, lambda lw=lbl_widget, g=gen: self._set_text_safe(lw, "Archivo de imagen inv√°lido", g))
                return

            img.thumbnail((820, 420))
            img_tk = ImageTk.PhotoImage(img)
            self.after(0, lambda lw=lbl_widget, im=img_tk, g=gen: self._set_img_safe(lw, im, g))

        except Exception as e:
            self.after(0, lambda lw=lbl_widget, g=gen: self._set_text_safe(lw, f"Error: {e}", g))

    @staticmethod
    def wait_file_stable(p, checks=6, delay=0.25):
        last = -1
        stable = 0
        for _ in range(checks * 10):
            if not os.path.exists(p):
                time.sleep(delay)
                continue
            try:
                sz = os.path.getsize(p)
            except:
                time.sleep(delay)
                continue

            if sz == last and sz > 0:
                stable += 1
                if stable >= checks:
                    return True
            else:
                stable = 0
                last = sz
            time.sleep(delay)
        return False



# ======================================================================
# Boss/Game semanal (integrado)
# ======================================================================
class PerformanceWindow(ctk.CTkToplevel):

    def __init__(self, master, username: str):
        super().__init__(master, fg_color=NAVY)

        ctk.CTkLabel(self, text=f"üìä Rendimiento ‚Ä¢ {username}",
                     font=("Roboto", 18, "bold")).pack(anchor="w", padx=16, pady=(14, 6))

        card = ctk.CTkFrame(self, fg_color=CARD, corner_radius=16)
        card.pack(fill="both", expand=True, padx=16, pady=16)

        ctk.CTkLabel(card, text="(Aqu√≠ va tu Performance real con gr√°ficos/KPIs)",
                     text_color=MUTED).pack(pady=30)


WEEKDAYS = ["Lun", "Mar", "Mi√©", "Jue", "Vie"]
ACTIONS = [
    ("Confirmaciones", 10),
    ("Ticketing/SSR", 10),
    ("Documentaci√≥n", 10),
    ("Pagos/Cobros", 10),
    ("Incidencia resuelta", 20),
]
MONDAY_MULT = 2

def monday_of_week(d: date) -> date:
    return d - timedelta(days=d.weekday())

def workweek_dates(anchor: Optional[date] = None) -> List[date]:
    anchor = anchor or datetime.now().date()
    mon = monday_of_week(anchor)
    return [mon + timedelta(days=i) for i in range(5)]

def is_monday(d: date) -> bool:
    return d.weekday() == 0

def week_key(mon: date) -> str:
    iso = mon.isocalendar()
    return f"{iso.year}-W{iso.week:02d}"

@dataclass
class Trophy:
    week: str
    title: str
    owner: str
    detail: str

@dataclass
class GameState:
    boss_hp_max: int = 1000
    boss_hp: int = 1000
    progress: Dict[str, Dict[str, Dict[str, Dict[str, bool]]]] = field(default_factory=dict)
    feed: List[str] = field(default_factory=list)
    trophies: List[Trophy] = field(default_factory=list)

    def ensure_week(self, wk: str, employees: List[str], dates: List[date]):
        if wk not in self.progress:
            self.progress[wk] = {}
        for emp in employees:
            if emp not in self.progress[wk]:
                self.progress[wk][emp] = {}
            for d in dates:
                ds = d.isoformat()
                if ds not in self.progress[wk][emp]:
                    self.progress[wk][emp][ds] = {name: False for name, _ in ACTIONS}

    def calc_damage_for_toggle(self, d: date, action_name: str) -> int:
        base = dict(ACTIONS)[action_name]
        return base * (MONDAY_MULT if is_monday(d) else 1)

    def employee_week_damage(self, wk: str, emp: str) -> int:
        if wk not in self.progress or emp not in self.progress[wk]:
            return 0
        total = 0
        for ds, acts in self.progress[wk][emp].items():
            dd = date.fromisoformat(ds)
            for name, done in acts.items():
                if done:
                    total += self.calc_damage_for_toggle(dd, name)
        return total

    def week_scoreboard(self, wk: str) -> List[Tuple[str, int]]:
        if wk not in self.progress:
            return []
        scores = [(emp, self.employee_week_damage(wk, emp)) for emp in self.progress[wk].keys()]
        scores.sort(key=lambda x: x[1], reverse=True)
        return scores

class GameStorage:
    def __init__(self, filepath=None):
        self.filepath = filepath or os.path.join(get_appdata_base_dir(), "game_state.json")

    def load(self) -> GameState:
        if not os.path.exists(self.filepath):
            return GameState()
        try:
            with open(self.filepath, "r", encoding="utf-8") as f:
                raw = json.load(f)
            gs = GameState()
            gs.boss_hp_max = raw.get("boss_hp_max", 1000)
            gs.boss_hp = raw.get("boss_hp", gs.boss_hp_max)
            gs.progress = raw.get("progress", {})
            gs.feed = raw.get("feed", [])
            gs.trophies = [Trophy(**t) for t in raw.get("trophies", [])]
            return gs
        except Exception:
            return GameState()

    def save(self, gs: GameState):
        raw = {
            "boss_hp_max": gs.boss_hp_max,
            "boss_hp": gs.boss_hp,
            "progress": gs.progress,
            "feed": gs.feed[-250:],
            "trophies": [t.__dict__ for t in gs.trophies],
        }
        with open(self.filepath, "w", encoding="utf-8") as f:
            json.dump(raw, f, ensure_ascii=False, indent=2)

class TrophiesModal(ctk.CTkToplevel):
    def __init__(self, master, trophies: List[Trophy]):
        super().__init__(master)
        self.title("Trofeos")
        self.geometry("760x520")
        self.configure(fg_color=NAVY)

        ctk.CTkLabel(self, text="üèÜ Trofeos", font=("Roboto", 18, "bold")).pack(anchor="w", padx=16, pady=12)
        scroll = ctk.CTkScrollableFrame(self, fg_color="transparent")
        scroll.pack(fill="both", expand=True, padx=16, pady=(0, 16))

        if not trophies:
            ctk.CTkLabel(scroll, text="Todav√≠a no hay trofeos guardados.").pack(pady=20)
            return

        for t in reversed(trophies[-60:]):
            card = ctk.CTkFrame(scroll, fg_color=CARD, corner_radius=16)
            card.pack(fill="x", padx=6, pady=6)
            ctk.CTkLabel(card, text=f"{t.week} ‚Ä¢ {t.title}", font=("Roboto", 13, "bold")).pack(anchor="w", padx=12, pady=(10, 2))
            ctk.CTkLabel(card, text=f"Ganador: {t.owner}", text_color=WARN).pack(anchor="w", padx=12)
            ctk.CTkLabel(card, text=t.detail, wraplength=680, justify="left").pack(anchor="w", padx=12, pady=(0, 10))

class BossGamePanel(ctk.CTkFrame):
    def __init__(self, master, employees: List[str], current_user: str, storage: GameStorage,
                 boss_name="Robot Semanal", can_view_scoreboard=True):
        super().__init__(master, fg_color="transparent")
        self.employees = employees
        self.current_user = current_user
        self.storage = storage
        self.state = storage.load()
        self.boss_name = boss_name
        self.can_view_scoreboard = can_view_scoreboard

        self.week_dates = workweek_dates()
        self.week_mon = self.week_dates[0]
        self.wk = week_key(self.week_mon)
        self.state.ensure_week(self.wk, employees, self.week_dates)

        self._build()
        self.render_all()

    def _build(self):
        top = ctk.CTkFrame(self, fg_color=CARD, corner_radius=16)
        top.pack(fill="x", padx=12, pady=12)

        row1 = ctk.CTkFrame(top, fg_color="transparent")
        row1.pack(fill="x", padx=12, pady=(12, 6))

        ctk.CTkLabel(row1, text="ü§ñ", font=("Roboto", 22)).pack(side="left", padx=(0, 10))
        self.lbl_boss = ctk.CTkLabel(row1, text=self.boss_name, font=("Roboto", 16, "bold"))
        self.lbl_boss.pack(side="left")

        ctk.CTkButton(row1, text="üèÜ Trofeos", width=120, command=self.open_trophies).pack(side="right")

        row2 = ctk.CTkFrame(top, fg_color="transparent")
        row2.pack(fill="x", padx=12, pady=(0, 12))
        self.hp_bar = ctk.CTkProgressBar(row2, width=520, progress_color="#e53935", fg_color="#0c1725")
        self.hp_bar.pack(side="left", padx=(0, 12))
        self.lbl_hp = ctk.CTkLabel(row2, text="HP: --/--")
        self.lbl_hp.pack(side="left")

        mid = ctk.CTkFrame(self, fg_color="transparent")
        mid.pack(fill="both", expand=True, padx=12, pady=(0, 12))

        self.calendar = ctk.CTkFrame(mid, fg_color=CARD, corner_radius=16)
        self.calendar.pack(side="left", fill="both", expand=True, padx=(0, 10))

        self.score = None
        self.score_list = None
        self.lbl_mvp = None
        if self.can_view_scoreboard:
            self.score = ctk.CTkFrame(mid, fg_color=CARD, corner_radius=16, width=320)
            self.score.pack(side="left", fill="y")
            self.score.pack_propagate(False)

        feed_box = ctk.CTkFrame(self, fg_color=CARD, corner_radius=16)
        feed_box.pack(fill="x", padx=12, pady=(0, 12))
        self.feed_text = ctk.CTkTextbox(feed_box, height=110)
        self.feed_text.pack(fill="both", expand=True, padx=10, pady=10)

        ctk.CTkLabel(self.calendar, text=f"Semana {self.wk} (Lunes doble)", font=("Roboto", 14, "bold")) \
            .pack(anchor="w", padx=12, pady=(12, 6))

        self.grid = ctk.CTkFrame(self.calendar, fg_color="transparent")
        self.grid.pack(fill="both", expand=True, padx=12, pady=12)

        self.day_cols = []
        for i, d in enumerate(self.week_dates):
            col = ctk.CTkFrame(self.grid, fg_color=CARD2, corner_radius=14)
            col.grid(row=0, column=i, padx=8, pady=8, sticky="nsew")
            self.grid.grid_columnconfigure(i, weight=1)

            title = f"{WEEKDAYS[i]}\n{d.strftime('%d/%m')}"
            ctk.CTkLabel(col, text=title, font=("Roboto", 12, "bold")).pack(pady=(10, 6))

            p = ctk.CTkProgressBar(col, width=130)
            p.pack(pady=(0, 10))
            p.set(0)

            buttons = {}
            for action_name, _ in ACTIONS:
                btn = ctk.CTkButton(col, text=action_name, height=34,
                                    command=lambda dd=d, aa=action_name: self.toggle_action(dd, aa))
                btn.pack(fill="x", padx=10, pady=4)
                buttons[action_name] = btn

            self.day_cols.append((d, p, buttons))

        if self.can_view_scoreboard:
            ctk.CTkLabel(self.score, text="üèÅ Scoreboard", font=("Roboto", 14, "bold")) \
                .pack(anchor="w", padx=12, pady=(12, 6))
            self.lbl_mvp = ctk.CTkLabel(self.score, text="MVP: ‚Äî", font=("Roboto", 12, "bold"))
            self.lbl_mvp.pack(anchor="w", padx=12, pady=(0, 8))

            self.score_list = ctk.CTkScrollableFrame(self.score, fg_color="transparent")
            self.score_list.pack(fill="both", expand=True, padx=10, pady=(0, 10))

    def open_trophies(self):
        TrophiesModal(self, self.state.trophies)

    def _refresh_week_if_needed(self):
        current_week = week_key(monday_of_week(datetime.now().date()))
        if current_week != self.wk:
            self.wk = current_week
            self.week_dates = workweek_dates()
            self.week_mon = self.week_dates[0]
            self.state.ensure_week(self.wk, self.employees, self.week_dates)

    def _feed(self, msg: str):
        self.state.feed.append(msg)
        self.storage.save(self.state)

    def _make_feed_msg(self, emp: str, action: str, dmg: int, d: date) -> str:
        mult = " (x2 lunes)" if is_monday(d) else ""
        return f"{datetime.now().strftime('%H:%M')} ‚Ä¢ {emp} complet√≥ '{action}'{mult} ‚ûú -{dmg} HP"

    def toggle_action(self, d: date, action_name: str):
        self._refresh_week_if_needed()
        emp = self.current_user
        ds = d.isoformat()

        self.state.ensure_week(self.wk, self.employees, self.week_dates)

        current = self.state.progress[self.wk][emp][ds][action_name]
        new_val = not current
        self.state.progress[self.wk][emp][ds][action_name] = new_val

        dmg = self.state.calc_damage_for_toggle(d, action_name)
        if new_val:
            self.state.boss_hp = max(0, self.state.boss_hp - dmg)
            self._feed(self._make_feed_msg(emp, action_name, dmg, d))
        else:
            # revertir "curaci√≥n" proporcional
            self.state.boss_hp = min(self.state.boss_hp_max, self.state.boss_hp + dmg)
            self._feed(f"{datetime.now().strftime('%H:%M')} ‚Ä¢ {emp} desmarc√≥ '{action_name}' ‚ûú +{dmg} HP")

        # si boss cae, guardar trofeo MVP de la semana
        if self.state.boss_hp <= 0:
            scores = self.state.week_scoreboard(self.wk)
            if scores:
                mvp, pts = scores[0]
                self.state.trophies.append(Trophy(
                    week=self.wk,
                    title="MVP Semana",
                    owner=mvp,
                    detail=f"Derrot√≥ al boss ‚Ä¢ Da√±o total: {pts}"
                ))
            self.state.boss_hp = self.state.boss_hp_max
            self._feed(f"{datetime.now().strftime('%H:%M')} ‚Ä¢ üéâ Boss derrotado. Semana reseteada.")

        self.storage.save(self.state)
        self.render_all()

    def render_all(self):
        hp = self.state.boss_hp
        mx = self.state.boss_hp_max
        self.hp_bar.set(hp / mx if mx else 0)
        self.lbl_hp.configure(text=f"HP: {hp}/{mx}")

        # Feed
        try:
            self.feed_text.delete("1.0", "end")
            self.feed_text.insert("end", "\n".join(self.state.feed[-30:]))
            self.feed_text.see("end")
        except:
            pass

        # Calendar buttons + per-day progress (solo del usuario actual)
        emp = self.current_user
        self.state.ensure_week(self.wk, self.employees, self.week_dates)

        for (d, pbar, buttons) in self.day_cols:
            ds = d.isoformat()
            acts = self.state.progress.get(self.wk, {}).get(emp, {}).get(ds, {})
            done_count = sum(1 for v in acts.values() if v)
            total_count = len(ACTIONS)
            frac = done_count / total_count if total_count else 0.0
            pbar.set(frac)

            for action_name, _ in ACTIONS:
                is_done = acts.get(action_name, False)
                btn = buttons[action_name]
                if is_done:
                    btn.configure(fg_color=OK, hover_color="#27ae60")
                else:
                    btn.configure(fg_color=CARD2, hover_color="#22324a")

        # Scoreboard (si corresponde)
        if self.can_view_scoreboard and self.score_list and self.lbl_mvp:
            for w in self.score_list.winfo_children():
                w.destroy()

            scores = self.state.week_scoreboard(self.wk)
            if scores:
                mvp, pts = scores[0]
                self.lbl_mvp.configure(text=f"MVP: {mvp} ‚Ä¢ {pts} pts")
            else:
                self.lbl_mvp.configure(text="MVP: ‚Äî")

            for i, (emp_name, pts) in enumerate(scores[:40], start=1):
                row = ctk.CTkFrame(self.score_list, fg_color=CARD2, corner_radius=12)
                row.pack(fill="x", padx=6, pady=4)

                ctk.CTkLabel(row, text=f"{i:02d}", width=36, text_color=MUTED).pack(side="left", padx=(10, 0))
                ctk.CTkLabel(row, text=emp_name, font=("Roboto", 12, "bold")).pack(side="left", padx=10)
                ctk.CTkLabel(row, text=f"{pts} pts", text_color=WARN).pack(side="right", padx=10)

    # ======================================================================
    # Rendimiento (placeholder simple -> vos ya ten√≠as PerformanceWindow)
    # ======================================================================
import re
from datetime import datetime
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# =========================
# Performance embebido (NO Toplevel)
# =========================
class PerfomanceView(ctk.CTkFrame):
    """
    ‚úÖ PerformanceView EMBEBIDO (Frame)
    - Tabs + gr√°ficos matplotlib embebidos (SIN animaciones para evitar ‚Äúcolgados‚Äù y canvases vac√≠os)
    - Selector de usuario FUNCIONAL (muestra todos y al cambiar recarga UI)
    - Top 3 FOCO / KPI / Tabla Apps / Comparador funcionando con parsers m√°s robustos
    - ELIMINADO: tab "Detalle"
    - Scoreboard Global: soporta claves distintas (active_sec / active / active_time_str / etc.)
    - Bot√≥n REFRESCAR: intenta actualizar datos si on_refresh retorna payload; si no, al menos re-renderiza tabs.
    - Export PDF: MUCH√çSIMA m√°s info (distracciones, conteos, % ocio, top ocio/productivo, resumen, etc.)
    """

    def __init__(
            self,
            master,
            target_user,
            active_time_str,
            inactive_time_str,
            history_raw,
            all_users_stats=None,
            on_refresh=None,
            user_list=None,
            on_change_user=None,
            max_width=800,
            max_height=720, on_load_all=None,
            topbar_frame=None, on_pick_user=None,on_request_ai_log=None,
            on_request_ai_summary=None,on_ai_chat = None):
        super().__init__(master, fg_color=NAVY)

        # ===== state base (SIEMPRE definidos) =====
        self.master_app = master
        self.target_user = target_user
        self.history_raw = history_raw or ""
        self.all_users_stats = all_users_stats or []
        self.on_refresh = on_refresh
        self.on_change_user = on_change_user
        self.selected_day = date.today()

        self.user_list = user_list or []
        self.selected_apps_to_compare = {}

        self.active_sec = 0
        self.inactive_sec = 0

        # figs/canvas refs (no cerrar con plt.close mientras est√°n embebidas)
        self.pie_fig = None
        self.pie_canvas = None
        self.on_pick_user = on_pick_user
        self.on_load_all = on_load_all
        self.all_users_stats = all_users_stats or []
        self._score_sort = "active"
        self.bar_fig = None
        self.bar_canvas = None
        self.on_ai_chat = on_ai_chat

        self.kpi_fig = None
        self.kpi_canvas = None
        self.all_users_stats = all_users_stats or []

        self.custom_fig = None
        self.custom_ax = None
        self.custom_canvas = None
        self.on_request_ai_log = on_request_ai_log
        self.on_request_ai_summary = on_request_ai_summary
        self._ai_log_text = ""  # cache del √∫ltimo log recibido
        self._ai_log_meta = ""  # ‚Äúuser/date‚Äù
        self.on_ai_chat = None  # callback opcional si lo quer√©s desde master
        self._ai_chat_history = []  # lista de (role, text)

        self.max_width = max_width
        self.max_height = max_height
        # =========================
        # ‚úÖ Estadistica avanzada (nuevo tab)
        # =========================
        self.adv_users = []  # lista de dicts: {name, role, eur_per_hour, color}
        self.adv_running = False
        self.adv_seconds = 0
        self.adv_total_seconds = 8 * 3600
        self.adv_days_per_month = 22

        self.adv_fig = None
        self.adv_ax = None
        self.adv_canvas = None
        self.adv_lines = {}  # key -> matplotlib line
        self.adv_data = {}   # key -> {"x":[], "y":[]}

        self.adv_hours_entry = None
        self.adv_date_entry = None
        self.adv_btn_start = None

        self._adv_tick_job = None

        # parse tiempos
        self.active_sec = self.parse_time_to_seconds(active_time_str)
        self.inactive_sec = self.parse_time_to_seconds(inactive_time_str)
        self.user_var = ctk.StringVar(value=target_user or "")
        self.on_pick_user = on_pick_user  # callback desde el cliente (pide stats)

        # UI + cargar tabs
        # UI + cargar tabs
        self._build_ui()

        # ‚úÖ FIX: si no hay historial, mostrar loading pero NO disparar request aqu√≠.
        # El request lo dispara _open_performance / _perf_pick_user desde KClientApp,
        # para evitar el doble disparo que causaba "queda cargando".
        if not (self.history_raw or "").strip():
            self.set_loading("Cargando datos del usuario...")
    def set_users(self, users):
        users = [u for u in (users or []) if u.strip()]
        self.user_menu.configure(values=users)

        cur = (self.user_var.get() or "").strip()

        # ‚úÖ prioridad absoluta al target_user
        if self.target_user and self.target_user in users:
            self.user_var.set(self.target_user)
        elif users and cur not in users:
            self.user_var.set(users[0])

    def _on_user_selected(self, user):
        user = (user or "").strip()
        if not user:
            return
        if user == getattr(self, "target_user", None):
            return

        # set selecci√≥n
        self.target_user = user
        try:
            if hasattr(self, "title_lbl") and self.title_lbl:
                self.title_lbl.configure(text=f"RENDIMIENTO: {user}")
        except:
            pass

        try:
            self.user_var.set(user)
        except:
            pass

        # feedback + limpiar para que NO parezca que qued√≥ pegado el anterior
        try:
            self.set_loading(f"Cargando datos de {user}‚Ä¶")
        except:
            pass

        # opcional: reset r√°pido (as√≠ los tabs no muestran datos viejos)
        self.active_sec = 0
        self.inactive_sec = 0
        self.history_raw = ""

        # ‚úÖ pedir datos: primero on_pick_user, si no existe usar on_change_user
        if callable(getattr(self, "on_pick_user", None)):
            self.on_pick_user(user)
        elif callable(getattr(self, "on_change_user", None)):
            try:
                self.on_change_user(user, self.selected_day)
            except TypeError:
                self.on_change_user(user)

        # render "vac√≠o" + loading mientras llegan stats
        try:
            self._render_all_tabs()
        except:
            pass

    # =========================
    # Helpers tiempo
    # =========================
    def parse_time_to_seconds(self, time_str):
        import re
        if not time_str:
            return 0
        try:
            s = str(time_str).lower()
            total = 0
            for val, unit in re.findall(r'(\d+)\s*([dhms])', s):
                val = int(val)
                if unit == 'd':
                    total += val * 86400
                elif unit == 'h':
                    total += val * 3600
                elif unit == 'm':
                    total += val * 60
                elif unit == 's':
                    total += val
            return total
        except:
            return 0

    def set_loading(self, msg="Cargando datos del usuario..."):
        # muestra un overlay simple arriba del tabview
        try:
            if hasattr(self, "_loading_overlay") and self._loading_overlay:
                self._loading_label.configure(text=msg)
                self._loading_overlay.lift()
                return
        except:
            pass

        self._loading_overlay = ctk.CTkFrame(self, fg_color="#000000")
        self._loading_overlay.place(relx=0, rely=0, relwidth=1, relheight=1)

        self._loading_label = ctk.CTkLabel(
            self._loading_overlay,
            text=msg,
            font=("Roboto", 18, "bold"),
            text_color=TURQ
        )
        self._loading_label.place(relx=0.5, rely=0.5, anchor="center")

    def clear_loading(self):
        try:
            if hasattr(self, "_loading_overlay") and self._loading_overlay:
                self._loading_overlay.destroy()
                self._loading_overlay = None
        except:
            pass

    def _schedule_render_tabs(self, delay_ms: int = 80):
        """Debounce de render para evitar congelamientos cuando llegan muchos mensajes seguidos."""
        try:
            prev = getattr(self, "_render_after_id", None)
            if prev:
                self.after_cancel(prev)
        except Exception:
            pass

        def _run():
            self._render_after_id = None
            self.clear_loading()
            self._render_all_tabs()

        try:
            self._render_after_id = self.after(max(0, int(delay_ms)), _run)
        except Exception:
            _run()

    def update_data(self, active_time_str=None, inactive_time_str=None, history_raw=None, all_users_stats=None,
                    user_list=None):
        # actualiza estado
        if active_time_str is not None:
            self.active_sec = self.parse_time_to_seconds(active_time_str)
        if inactive_time_str is not None:
            self.inactive_sec = self.parse_time_to_seconds(inactive_time_str)
        if history_raw is not None:
            self.history_raw = history_raw or ""
        if all_users_stats is not None:
            self.all_users_stats = all_users_stats or []
        if user_list is not None:
            self.user_list = user_list or []
            self._refresh_user_menu_values()
        if all_users_stats is not None:
            self.all_users_stats = all_users_stats

        # quita loading y re-renderiza (debounced para evitar picos)
        self._schedule_render_tabs(80)

    def _parse_duration_to_seconds(self, s: str) -> int:
        import re
        if not s:
            return 0
        s = str(s).strip().lower().replace("[", "").replace("]", "")
        total = 0
        for val, unit in re.findall(r"(\d+)\s*([dhms])", s):
            val = int(val)
            if unit == "d":
                total += val * 86400
            elif unit == "h":
                total += val * 3600
            elif unit == "m":
                total += val * 60
            elif unit == "s":
                total += val
        return total

    def format_seconds(self, seconds):
        try:
            s = int(seconds)
            d = s // 86400
            h = (s % 86400) // 3600
            m = (s % 3600) // 60
            return f"{d}d {h}h {m}m"
        except:
            return "0d 0h 0m"

    # =========================
    # UI base + Tabs
    # =========================
    def _build_ui(self):
        # Header
        header = ctk.CTkFrame(self, fg_color=CARD)
        header.pack(fill="x", padx=14, pady=(14, 8))

        # Left: Title + User selector
        left = ctk.CTkFrame(header, fg_color="transparent")
        left.pack(side="left", padx=12, pady=10)

        self.title_lbl = ctk.CTkLabel(
            left,
            text=f"RENDIMIENTO: {self.target_user}",
            font=("Roboto", 18, "bold"),
            text_color=TURQ
        )
        self.title_lbl.pack(side="left", padx=(0, 12))

        values = list(self.user_list) if self.user_list else []
        if self.target_user and self.target_user not in values:
            values = [self.target_user] + values
        if not values:
            values = [self.target_user] if self.target_user else ["---"]

        self.user_menu = ctk.CTkOptionMenu(
            left,
            values=values,
            width=220,
            variable=self.user_var,
            command=self._on_user_selected
        )

        try:
            self.user_menu.set(self.target_user if self.target_user in values else values[0])
        except:
            pass
        self.user_menu.pack(side="left")

        # --- D√≠a (YYYY-MM-DD) ---
        self.day_var = tk.StringVar(value=self.selected_day)
        day_box = ctk.CTkFrame(header, fg_color="transparent")
        day_box.pack(side="left", padx=(12, 0))

        self.btn_prev_day = ctk.CTkButton(day_box, text="‚óÄ", width=28, command=lambda: self._shift_day(-1))
        self.btn_prev_day.pack(side="left", padx=(0, 6))

        self.day_entry = ctk.CTkEntry(day_box, width=110, textvariable=self.day_var, placeholder_text="YYYY-MM-DD")
        self.day_entry.pack(side="left")
        self.day_entry.bind("<Return>", lambda e: self._apply_day_from_entry())
        self.day_entry.bind("<FocusOut>", lambda e: self._apply_day_from_entry())

        self.btn_today = ctk.CTkButton(day_box, text="Hoy", width=50, command=self._set_today)
        self.btn_today.pack(side="left", padx=(6, 6))

        self.btn_next_day = ctk.CTkButton(day_box, text="‚ñ∂", width=28, command=lambda: self._shift_day(1))
        self.btn_next_day.pack(side="left")

        # Right: Buttons
        btns = ctk.CTkFrame(header, fg_color="transparent")
        btns.pack(side="right", padx=10, pady=10)

        ctk.CTkButton(
            btns,
            text="REFRESCAR",
            width=120,
            fg_color="#34495e",
            command=self._handle_refresh
        ).pack(side="left", padx=6)

        ctk.CTkButton(
            btns,
            text="EXPORT PDF",
            width=120,
            fg_color="#8e44ad",
            command=self.export_user_pdf
        ).pack(side="left", padx=6)

        # Tabview
        self.tabview = ctk.CTkTabview(self)
        self.tabview.pack(fill="both", expand=True, padx=14, pady=(0, 14))

        # ‚úÖ eliminado "Detalle"
        self._tabs = [
            "Actividad vs Inactividad",
            "Top 3 (FOCO)",
            "Comparador",
            "KPI (FOCO)",
            "Tabla Apps (FOCO)",
            "Historial Crudo",
            "Scoreboard Global",
            "Herramientas IA",
            "Estadistica avanzada",  # ‚úÖ NUEVO
        ]

        for t in self._tabs:
            self.tabview.add(t)

        # Limitar tama√±o
        self.configure(width=self.max_width, height=self.max_height)
        self.pack_propagate(False)
        self.tabview.configure(width=self.max_width - 28, height=self.max_height - 90)
        self.tabview.pack_propagate(False)

        # Cargar tabs
        self._render_all_tabs()
        self.tabview.set("Actividad vs Inactividad")

    def _set_selected_day(self, d: date, *, notify_server: bool = True):
        """Set selected day for *all* performance queries/UI."""
        try:
            if not isinstance(d, date):
                return
            self.selected_day = d
            iso = d.isoformat()
            # Keep entry in sync
            if hasattr(self, "day_var") and self.day_var is not None:
                self.day_var.set(iso)

            if hasattr(self, "day_entry") and self.day_entry is not None:
                try:
                    self.day_entry.delete(0, "end")
                    self.day_entry.insert(0, iso)
                except Exception:
                    pass

            if hasattr(self, "day_label") and self.day_label is not None:
                try:
                    self.day_label.configure(text=iso)
                except Exception:
                    pass

            if notify_server:
                # ‚úÖ FIX: mostrar loading mientras llegan datos del nuevo d√≠a
                try:
                    self.set_loading(f"Cargando {iso}‚Ä¶")
                except Exception:
                    pass

                # Pedir stats del d√≠a elegido al server
                if self.target_user and callable(getattr(self, "on_pick_user", None)):
                    try:
                        self.on_pick_user(self.target_user, iso)
                    except Exception:
                        pass

                # NOTA: no disparamos barrido global autom√°tico al cambiar d√≠a.
                # Esto evit√≥ duplicados/solapes de REQUEST_USER_STATS y respuestas pisadas.
                # El scoreboard puede refrescarse bajo demanda desde su propia UI.

        except Exception:
            pass

    def _set_today(self):
        self._set_selected_day(date.today())

    def _shift_day(self, delta_days: int):
        try:
            self._set_selected_day(self.selected_day + timedelta(days=int(delta_days)))
        except Exception:
            self._set_selected_day(date.today())

    def _apply_day_from_entry(self, *_):
        raw = (self.day_var.get() if hasattr(self, "day_var") else "").strip()
        try:
            d = datetime.strptime(raw, "%Y-%m-%d").date()
        except Exception:
            # If user typed something invalid, snap back to current selected_day
            try:
                self.day_var.set(self.selected_day.isoformat())
            except Exception:
                pass
            return
        self._set_selected_day(d)

    def _dispose_figures(self):
        for name in ("pie_fig", "bar_fig", "kpi_fig", "custom_fig", "adv_fig"):
            fig = getattr(self, name, None)
            if fig is not None:
                try:
                    plt.close(fig)
                except Exception:
                    pass
                setattr(self, name, None)

    def _render_all_tabs(self):
        self._dispose_figures()
        self._safe_setup("Actividad vs Inactividad", self.setup_pie_chart)
        self._safe_setup("Top 3 (FOCO)", self.setup_bar_chart)
        self._safe_setup("Comparador", self.setup_custom_chart)
        self._safe_setup("KPI (FOCO)", self.setup_quality_chart)
        self._safe_setup("Tabla Apps (FOCO)", self.setup_table_tab)
        self._safe_setup("Historial Crudo", self.setup_raw_history_tab)
        self._safe_setup("Scoreboard Global", lambda: self.setup_scoreboard("active"))
        self._safe_setup("Herramientas IA", self.setup_ai_tools_tab)
        self._safe_setup("Estadistica avanzada", self.setup_advanced_stats_tab)


    def setup_ai_tools_tab(self):
        tab = self.tabview.tab("Herramientas IA")
        for w in tab.winfo_children():
            w.destroy()

        # ---------- Estilo ----------
        BG = NAVY
        PANEL = CARD
        PANEL2 = CARD2
        BORDER = "#1f334a"
        TXT = "white"
        MUT = "#a9bfd8"
        ACC = TURQ

        USER_BUBBLE = "#16354a"
        ASSIST_BUBBLE = "#0f2436"
        USER_EDGE = "#245a73"
        ASSIST_EDGE = "#1e3a55"

        # ---------- Header ----------
        header = ctk.CTkFrame(tab, fg_color=PANEL, corner_radius=14)
        header.pack(fill="x", padx=14, pady=(14, 10))

        user = (self.user_var.get() or self.target_user or "").strip()

        left = ctk.CTkFrame(header, fg_color="transparent")
        left.pack(side="left", padx=12, pady=12, fill="x", expand=True)

        ctk.CTkLabel(
            left,
            text="Asistente IA",
            font=("Roboto", 18, "bold"),
            text_color=TXT
        ).pack(anchor="w")

        ctk.CTkLabel(
            left,
            text=f"CSD VIAJES ¬∑ Panel de an√°lisis ¬∑ Usuario: {user or '‚Äî'}",
            font=("Roboto", 12),
            text_color=MUT
        ).pack(anchor="w", pady=(2, 0))

        right = ctk.CTkFrame(header, fg_color="transparent")
        right.pack(side="right", padx=12, pady=12)

        # Controles (fecha + l√≠neas)
        self.ai_date_entry = ctk.CTkEntry(right, width=140, placeholder_text="YYYY-MM-DD")
        self.ai_date_entry.grid(row=0, column=0, padx=(0, 8), pady=(0, 6))
        try:
            self.ai_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        except:
            pass

        self.ai_lines_entry = ctk.CTkEntry(right, width=90, placeholder_text="300")
        self.ai_lines_entry.grid(row=0, column=1, padx=(0, 8), pady=(0, 6))
        try:
            self.ai_lines_entry.insert(0, "300")
        except:
            pass

        # ---------- Layout principal: izquierda (contexto) / derecha (chat) ----------
        main = ctk.CTkFrame(tab, fg_color="transparent")
        main.pack(fill="both", expand=True, padx=14, pady=(0, 14))

        main.grid_columnconfigure(0, weight=1)
        main.grid_columnconfigure(1, weight=2)
        main.grid_rowconfigure(0, weight=1)

        # ========== Panel Contexto (Log) ==========
        ctx = ctk.CTkFrame(main, fg_color=PANEL2, corner_radius=14, border_width=1, border_color=BORDER)
        ctx.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=0)
        ctx.grid_rowconfigure(2, weight=1)

        top_ctx = ctk.CTkFrame(ctx, fg_color="transparent")
        top_ctx.grid(row=0, column=0, sticky="ew", padx=12, pady=(12, 6))
        top_ctx.grid_columnconfigure(0, weight=1)

        ctk.CTkLabel(
            top_ctx,
            text="Contexto y Logs",
            font=("Roboto", 14, "bold"),
            text_color=TXT
        ).grid(row=0, column=0, sticky="w")

        self._ai_meta_lbl = ctk.CTkLabel(
            top_ctx,
            text=self._ai_log_meta or "‚Äî",
            font=("Consolas", 11),
            text_color=MUT
        )
        self._ai_meta_lbl.grid(row=1, column=0, sticky="w", pady=(6, 0))

        btn_row = ctk.CTkFrame(ctx, fg_color="transparent")
        btn_row.grid(row=1, column=0, sticky="ew", padx=12, pady=(6, 10))

        def _safe_int(x, default=300):
            try:
                return int((x or "").strip())
            except:
                return default

        def _req_log():
            u = (self.user_var.get() or self.target_user or "").strip()
            day = (self.ai_date_entry.get() or "").strip()
            max_lines = _safe_int(self.ai_lines_entry.get(), 300)

            if not u:
                return

            if not day:
                try:
                    day = datetime.now().strftime("%Y-%m-%d")
                except:
                    day = ""

            # UI feedback neutro
            self._ai_log_meta = f"{u} ‚Äî {day}"
            try:
                self._ai_meta_lbl.configure(text=self._ai_log_meta)
            except:
                pass

            self._set_log_box_text("Cargando log IA‚Ä¶", color="#dbe9ff")

            if callable(self.on_request_ai_log):
                try:
                    self.on_request_ai_log(u, day, max_lines)
                except:
                    # sin errores feos
                    self._set_log_box_text("No se pudo solicitar el log en este momento.", color="#ffd6d6")
            else:
                self._set_log_box_text("La funci√≥n de solicitud de log no est√° configurada.", color="#ffd6d6")

        def _req_summary():
            u = (self.user_var.get() or self.target_user or "").strip()
            day = (self.ai_date_entry.get() or "").strip()
            if not u:
                return
            if not day:
                try:
                    day = datetime.now().strftime("%Y-%m-%d")
                except:
                    day = ""

            # Si ten√©s callback resumen, usalo. Si no, pedimos por chat.
            if callable(self.on_request_ai_summary):
                try:
                    self.on_request_ai_summary(u, day)
                    self._append_chat("assistant",
                                      "Perfecto. En cuanto llegue el contexto, te preparo el resumen operativo.")
                except:
                    self._append_chat("assistant", "No pude pedir el resumen en este momento.")
            else:
                # fallback: pregunta directa a la IA usando el chat
                self._ai_chat_history.append(("user",
                                              "Haceme un resumen operativo del d√≠a: productivo vs ocio, puntos de riesgo y recomendaciones."))
                self._render_ai_chat_history()
                self._send_ai_chat_from_ui(force_last_user_message=True)

        def _copy_log():
            try:
                txt = self._ai_log_text or ""
                if not txt.strip():
                    return
                self.clipboard_clear()
                self.clipboard_append(txt)
                # feedback breve en chat
                self._append_chat("assistant", "Log copiado al portapapeles.")
            except:
                pass

        ctk.CTkButton(
            btn_row, text="RECIBIR LOG", width=140, fg_color="#34495e",
            hover_color="#2c3e50", command=_req_log
        ).pack(side="left", padx=(0, 8))

        ctk.CTkButton(
            btn_row, text="PEDIR RESUMEN", width=150, fg_color="#1f6f67",
            hover_color="#17615a", command=_req_summary
        ).pack(side="left", padx=(0, 8))

        ctk.CTkButton(
            btn_row, text="COPIAR", width=90, fg_color="#8e44ad",
            hover_color="#7d3c98", command=_copy_log
        ).pack(side="left")

        # Log box
        self._ai_log_textbox = ctk.CTkTextbox(
            ctx,
            fg_color="#0b111a",
            text_color="#dbe9ff",
            font=("Consolas", 12),
            corner_radius=12
        )
        self._ai_log_textbox.grid(row=2, column=0, sticky="nsew", padx=12, pady=(0, 12))
        try:
            self._ai_log_textbox.insert("1.0", self._ai_log_text or "Todav√≠a no hay log cargado.")
            self._ai_log_textbox.configure(state="disabled")
        except:
            pass

        # ========== Panel Chat ==========
        chat = ctk.CTkFrame(main, fg_color=PANEL2, corner_radius=14, border_width=1, border_color=BORDER)
        chat.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=0)
        chat.grid_rowconfigure(1, weight=1)
        chat.grid_columnconfigure(0, weight=1)

        # Header chat tipo ‚ÄúChatGPT‚Äù
        chat_head = ctk.CTkFrame(chat, fg_color="transparent")
        chat_head.grid(row=0, column=0, sticky="ew", padx=12, pady=(12, 8))
        chat_head.grid_columnconfigure(0, weight=1)

        ctk.CTkLabel(
            chat_head,
            text="Chat",
            font=("Roboto", 14, "bold"),
            text_color=TXT
        ).grid(row=0, column=0, sticky="w")

        ctk.CTkLabel(
            chat_head,
            text="Escrib√≠ una pregunta y te respondo con base en el log + historial.",
            font=("Roboto", 12),
            text_color=MUT
        ).grid(row=1, column=0, sticky="w", pady=(3, 0))

        # √Årea scrolleable de mensajes (burbujas)
        self._ai_chat_scroll = ctk.CTkScrollableFrame(chat, fg_color="transparent")
        self._ai_chat_scroll.grid(row=1, column=0, sticky="nsew", padx=12, pady=(0, 10))

        # Input + send
        input_bar = ctk.CTkFrame(chat, fg_color="transparent")
        input_bar.grid(row=2, column=0, sticky="ew", padx=12, pady=(0, 12))
        input_bar.grid_columnconfigure(0, weight=1)

        self._ai_chat_entry = ctk.CTkTextbox(
            input_bar,
            height=56,
            fg_color="#0b111a",
            text_color="white",
            font=("Roboto", 13),
            corner_radius=12
        )
        self._ai_chat_entry.grid(row=0, column=0, sticky="ew", padx=(0, 10))

        def _send():
            self._send_ai_chat_from_ui()

        self._ai_chat_send_btn = ctk.CTkButton(
            input_bar,
            text="ENVIAR",
            width=120,
            fg_color=ACC,
            text_color="#001013",
            hover_color="#14bdb1",
            command=_send
        )
        self._ai_chat_send_btn.grid(row=0, column=1, sticky="e")

        # Enter env√≠a (Shift+Enter salto l√≠nea)
        try:
            def _on_key(e):
                # Shift+Enter => nueva l√≠nea
                if (e.state & 0x0001) != 0:
                    return
                _send()
                return "break"

            self._ai_chat_entry.bind("<Return>", _on_key)
        except:
            pass

        # Helpers internos para estilos/burbujas (guardamos en self para usar luego)
        self._ai_ui = {
            "TXT": TXT, "MUT": MUT,
            "USER_BUBBLE": USER_BUBBLE, "ASSIST_BUBBLE": ASSIST_BUBBLE,
            "USER_EDGE": USER_EDGE, "ASSIST_EDGE": ASSIST_EDGE
        }

        # Render historial si hab√≠a
        self._render_ai_chat_history()

    def _set_log_box_text(self, text: str, color: str = "#dbe9ff"):
        try:
            self._ai_log_textbox.configure(state="normal", text_color=color)
            self._ai_log_textbox.delete("1.0", "end")
            self._ai_log_textbox.insert("1.0", text or "")
            self._ai_log_textbox.see("1.0")
            self._ai_log_textbox.configure(state="disabled")
        except:
            pass

    def _append_chat(self, role: str, msg: str):
        self._ai_chat_history.append((role, msg))
        self._render_ai_chat_history()
    # =========================
    # ‚úÖ TAB: Estadistica avanzada
    # =========================
    def setup_advanced_stats_tab(self):
        tab = self.tabview.tab("Estadistica avanzada")
        for w in tab.winfo_children():
            w.destroy()

        BG = NAVY
        PANEL = CARD2
        BORDER = "#1f334a"
        TXT = "white"
        MUT = "#a9bfd8"
        ACC = TURQ

        # Layout: izquierda gr√°fico / derecha panel
        root = ctk.CTkFrame(tab, fg_color="transparent")
        root.pack(fill="both", expand=True, padx=14, pady=14)

        root.grid_columnconfigure(0, weight=3)
        root.grid_columnconfigure(1, weight=1)
        root.grid_rowconfigure(0, weight=1)

        left = ctk.CTkFrame(root, fg_color=PANEL, corner_radius=14, border_width=1, border_color=BORDER)
        left.grid(row=0, column=0, sticky="nsew", padx=(0, 10))
        left.grid_rowconfigure(1, weight=1)
        left.grid_columnconfigure(0, weight=1)

        right = ctk.CTkFrame(root, fg_color=PANEL, corner_radius=14, border_width=1, border_color=BORDER)
        right.grid(row=0, column=1, sticky="nsew", padx=(10, 0))
        right.grid_rowconfigure(6, weight=1)
        right.grid_columnconfigure(0, weight=1)

        # ---- header izquierda
        head = ctk.CTkFrame(left, fg_color="transparent")
        head.grid(row=0, column=0, sticky="ew", padx=12, pady=(12, 6))
        head.grid_columnconfigure(0, weight=1)

        ctk.CTkLabel(head, text="Estadistica avanzada", font=("Roboto", 16, "bold"), text_color=TXT).grid(
            row=0, column=0, sticky="w"
        )
        ctk.CTkLabel(
            head,
            text="‚Ç¨ acumulados vs segundos del d√≠a (l√≠nea real y efectiva por KPI)",
            font=("Roboto", 12),
            text_color=MUT
        ).grid(row=1, column=0, sticky="w", pady=(4, 0))

        # ---- gr√°fico
        fig, ax = plt.subplots(figsize=(7.2, 4.3), dpi=100)
        fig.patch.set_facecolor("#1a1a1a")
        ax.set_facecolor("#1a1a1a")
        ax.tick_params(colors="white")
        for s in ax.spines.values():
            s.set_color("#444")

        ax.set_xlabel("Segundos del d√≠a", color="white")
        ax.set_ylabel("‚Ç¨ acumulados", color="white")

        self.adv_fig = fig
        self.adv_ax = ax

        canvas = FigureCanvasTkAgg(fig, master=left)
        canvas.draw()
        canvas.get_tk_widget().grid(row=1, column=0, sticky="nsew", padx=12, pady=(0, 12))
        self.adv_canvas = canvas

        # Setear l√≠mites por defecto
        self._adv_apply_axes_limits()

        # ---- panel derecho
        ctk.CTkLabel(right, text="Controles", font=("Roboto", 14, "bold"), text_color=TXT).grid(
            row=0, column=0, sticky="w", padx=12, pady=(12, 6)
        )
        # ---- panel derecho (header)
        head_r = ctk.CTkFrame(right, fg_color="transparent")
        head_r.grid(row=0, column=0, sticky="ew", padx=12, pady=(12, 6))
        head_r.grid_columnconfigure(0, weight=1)
        head_r.grid_columnconfigure(1, weight=0)

        ctk.CTkLabel(head_r, text="Controles", font=("Roboto", 14, "bold"), text_color=TXT).grid(
            row=0, column=0, sticky="w"
        )

        self._adv_totals_lbl = ctk.CTkLabel(
            head_r,
            text="Total ahora: 0.0000 ‚Ç¨/s (efectivo)",
            font=("Consolas", 12),
            text_color=ACC
        )
        self._adv_totals_lbl.grid(row=0, column=1, sticky="e")

        # Fecha
        self.adv_date_entry = ctk.CTkEntry(right, placeholder_text="YYYY-MM-DD")
        self.adv_date_entry.grid(row=1, column=0, sticky="ew", padx=12, pady=(0, 8))
        try:
            self.adv_date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
        except:
            pass

        # Horas/d√≠a
        self.adv_hours_entry = ctk.CTkEntry(right, placeholder_text="Horas objetivo del d√≠a (8)")
        self.adv_hours_entry.grid(row=2, column=0, sticky="ew", padx=12, pady=(0, 8))
        try:
            self.adv_hours_entry.insert(0, "8")
        except:
            pass

        # Botones
        btn_row = ctk.CTkFrame(right, fg_color="transparent")
        btn_row.grid(row=3, column=0, sticky="ew", padx=12, pady=(6, 10))
        btn_row.grid_columnconfigure(0, weight=1)
        btn_row.grid_columnconfigure(1, weight=1)

        ctk.CTkButton(
            btn_row,
            text="A√ëADIR",
            fg_color="#27ae60",
            hover_color="#1f8a4c",
            command=self._adv_add_user_dialog
        ).grid(row=0, column=0, sticky="ew", padx=(0, 6))

        self.adv_btn_start = ctk.CTkButton(
            btn_row,
            text="EMPEZAR",
            fg_color=ACC,
            text_color="#001013",
            hover_color="#14bdb1",
            command=self._adv_start_stop
        )
        self.adv_btn_start.grid(row=0, column=1, sticky="ew", padx=(6, 0))
        ctk.CTkButton(
            right,
            text="Resetear todo",
            fg_color="#7f1d1d",
            hover_color="#991b1b",
            command=self._adv_reset_all
        ).grid(row=6, column=0, sticky="ew", padx=12, pady=(14, 6))

        # Listado usuarios
        ctk.CTkLabel(right, text="Usuarios a√±adidos", font=("Roboto", 12, "bold"), text_color=TXT).grid(
            row=4, column=0, sticky="w", padx=12, pady=(8, 4)
        )

        self._adv_users_box = ctk.CTkTextbox(right, height=160, fg_color="#0b111a", text_color="#dbe9ff",
                                             font=("Consolas", 11), corner_radius=12)
        self._adv_users_box.grid(row=5, column=0, sticky="nsew", padx=12, pady=(0, 10))
        self._adv_refresh_users_box()

        # Nota mensual
        ctk.CTkLabel(
            right,
            text=f"Mes: {self.adv_days_per_month} d√≠as ¬∑ Efectivo = Real / max(KPI, 20%)",
            font=("Roboto", 11),
            text_color=MUT
        ).grid(row=7, column=0, sticky="w", padx=12, pady=(0, 12))

        # si ven√≠a corriendo y re-renderizaste el tab, asegurate de redibujar l√≠neas
        self._adv_redraw_all_lines()
        self._adv_refresh_totals()
    def _adv_random_color(self) -> str:
        # colores vivos, evita muy oscuros
        r = random.randint(60, 240)
        g = random.randint(60, 240)
        b = random.randint(60, 240)
        return f"#{r:02x}{g:02x}{b:02x}"

    def _adv_get_selected_day(self) -> str:
        try:
            day = (self.adv_date_entry.get() or "").strip()
            if day:
                return day
        except:
            pass
        try:
            return datetime.now().strftime("%Y-%m-%d")
        except:
            return ""

    def _adv_reset_all(self):
        from tkinter import messagebox

        if not messagebox.askyesno(
                "Resetear todo",
                "Esto borrar√° todos los usuarios y la simulaci√≥n actual.\n¬øContinuar?"
        ):
            return

        # parar simulaci√≥n
        self.adv_running = False

        # cancelar el after correcto
        try:
            if self._adv_tick_job:
                self.after_cancel(self._adv_tick_job)
        except:
            pass
        self._adv_tick_job = None

        # reset tiempo
        self.adv_seconds = 0

        # borrar usuarios
        self.adv_users = []

        # borrar l√≠neas + data
        self.adv_lines = {}
        self.adv_data = {}

        # limpiar gr√°fico
        try:
            if self.adv_ax:
                self.adv_ax.clear()
                self.adv_ax.set_facecolor("#1a1a1a")
                self.adv_ax.tick_params(colors="white")
                for s in self.adv_ax.spines.values():
                    s.set_color("#444")
                self.adv_ax.set_xlabel("Segundos del d√≠a", color="white")
                self.adv_ax.set_ylabel("‚Ç¨ acumulados", color="white")
                self._adv_apply_axes_limits()
                self._adv_autoscale_y()
            if self.adv_canvas:
                self.adv_canvas.draw_idle()
        except:
            pass

        # limpiar box
        try:
            self._adv_users_box.configure(state="normal")
            self._adv_users_box.delete("1.0", "end")
            self._adv_users_box.insert("1.0", "‚Äî Ninguno ‚Äî")
            self._adv_users_box.configure(state="disabled")
        except:
            pass

        # reset totals
        try:
            if hasattr(self, "_adv_totals_lbl") and self._adv_totals_lbl:
                self._adv_totals_lbl.configure(text="Total ahora: 0.0000 ‚Ç¨/s (efectivo)")
        except:
            pass

    def _adv_get_user_raw_for_ai(self, username: str) -> str:
        # 1) si es el usuario actual (target_user) => self.history_raw
        try:
            if (username or "").strip() == (self.target_user or "").strip():
                return (self.history_raw or "").strip()
        except:
            pass

        # 2) si existe en all_users_stats con 'raw'
        try:
            for u in (self.all_users_stats or []):
                if not isinstance(u, dict):
                    continue
                name = u.get("name") or u.get("user") or u.get("username")
                if (name or "").strip() != (username or "").strip():
                    continue
                raw = u.get("raw")
                if isinstance(raw, str) and raw.strip():
                    return raw.strip()
        except:
            pass

        return ""

    def _adv_user_cost_per_sec(self, u: dict) -> tuple[float, float, int]:
        """
        Devuelve:
        - real ‚Ç¨/s
        - efectivo ‚Ç¨/s (real dividido por KPI)
        - kpi_pct (20..100) objetivo (FOCO)
        """
        eur_h = float(u.get("eur_per_hour") or 0.0)
        real = eur_h / 3600.0

        name = (u.get("name") or "").strip()
        kpi_ratio = self._adv_get_user_kpi(name)  # 0..1 objetivo
        kpi_pct = int(round(kpi_ratio * 100))

        # piso y techo para no explotar la l√≠nea
        if kpi_pct < 20:
            kpi_pct = 20
        if kpi_pct > 100:
            kpi_pct = 100

        ratio = kpi_pct / 100.0
        effective = real / ratio
        return real, effective, kpi_pct

    def _adv_refresh_totals(self):
        total_eff = 0.0
        for u in (self.adv_users or []):
            _, eff, _ = self._adv_user_cost_per_sec(u)
            total_eff += eff

        try:
            if hasattr(self, "_adv_totals_lbl") and self._adv_totals_lbl:
                self._adv_totals_lbl.configure(text=f"Total ahora: {total_eff:.4f} ‚Ç¨/s (efectivo)")
        except:
            pass

    def _adv_request_ai_efficiency_async(self, username: str):
        day = self._adv_get_selected_day()

        # cache por d√≠a
        for u in self.adv_users:
            if u.get("name") == username and u.get("ai_eff") is not None and u.get("ai_eff_day") == day:
                return

        raw = self._adv_get_user_raw_for_ai(username)
        if not raw:
            # sin raw => fallback fijo
            for u in self.adv_users:
                if u.get("name") == username:
                    u["ai_eff"] = 80
                    u["ai_eff_day"] = day
                    break
            self._adv_refresh_users_box()
            self._adv_refresh_totals()
            return

        # recorte para no mandar infinito
        if len(raw) > 12000:
            raw = raw[-12000:]

        threading.Thread(
            target=self._adv_ai_eff_worker,
            args=(username, day, raw),
            daemon=True
        ).start()

    def _adv_ai_eff_worker(self, username: str, day: str, raw: str):
        score = None
        try:
            from openai import OpenAI
            client = OpenAI()

            system_prompt = (
                "Sos un analista de productividad para una agencia de viajes.\n"
                "Ten√©s que puntuar la efectividad real del d√≠a en una escala del 1 al 100.\n"
                "Basate SOLO en el log/historial proporcionado.\n"
                "No inventes.\n"
                "Respond√© SOLO un n√∫mero entero (sin texto extra).\n"
            )

            user_prompt = (
                f"Usuario: {username}\n"
                f"Fecha: {day}\n\n"
                "Historial RAW:\n"
                f"{raw}\n\n"
                "Criterio:\n"
                "- 100 = foco y tareas claramente productivas casi todo el tiempo.\n"
                "- 50 = mezcla fuerte de productivo y ocio/dispersi√≥n.\n"
                "- 20 = muy poco productivo.\n"
                "Devolv√© SOLO el n√∫mero entero 1..100.\n"
            )

            resp = client.responses.create(
                model="gpt-4o-mini",
                input=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt},
                ]
            )

            out_text = ""
            for item in getattr(resp, "output", []) or []:
                if getattr(item, "type", None) == "message":
                    for c in getattr(item, "content", []) or []:
                        if getattr(c, "type", None) in ("output_text", "text"):
                            out_text += getattr(c, "text", "")

            out_text = (out_text or "").strip()
            m = re.search(r"(\d{1,3})", out_text)
            if m:
                score = int(m.group(1))
        except:
            score = None

        if score is None:
            score = 80
        if score < 1:
            score = 1
        if score > 100:
            score = 100

        def ui():
            for u in self.adv_users:
                if u.get("name") == username:
                    u["ai_eff"] = score
                    u["ai_eff_day"] = day
                    break
            self._adv_refresh_users_box()
            self._adv_refresh_totals()
            # redibujo opcional (no obligatorio, pero mantiene todo coherente)
            self._adv_redraw_all_lines()

        try:
            self.after(0, ui)
        except:
            ui()

    def _adv_refresh_users_box(self):
        try:
            self._adv_users_box.configure(state="normal")
            self._adv_users_box.delete("1.0", "end")

            if not self.adv_users:
                self._adv_users_box.insert("1.0", "‚Äî Ninguno ‚Äî")
            else:
                for u in self.adv_users:
                    real_s, eff_s, kpi_pct = self._adv_user_cost_per_sec(u)
                    ai_txt = str(u.get("ai_eff")) if u.get("ai_eff") is not None else "pendiente"

                    self._adv_users_box.insert(
                        "end",
                        f"{u['name']} | {u['role']} | {u['eur_per_hour']} ‚Ç¨/h | KPI={kpi_pct}% | real={real_s:.4f} ‚Ç¨/s | eff={eff_s:.4f} ‚Ç¨/s\n"
                    )

            self._adv_users_box.configure(state="disabled")
        except:
            pass

        self._adv_refresh_totals()

    def _adv_apply_axes_limits(self):
        # total segundos seg√∫n entry (si existe)
        total = self.adv_total_seconds
        try:
            if self.adv_hours_entry:
                h = float((self.adv_hours_entry.get() or "8").strip())
                if h <= 0:
                    h = 8.0
                total = int(h * 3600)
        except:
            pass
        self.adv_total_seconds = total

        if self.adv_ax:
            self.adv_ax.set_xlim(0, max(1, total))
            # y auto (lo ajustamos din√°micamente en cada tick)

    def _adv_add_user_dialog(self):
        win = ctk.CTkToplevel(self)
        win.title("A√±adir usuario")
        win.geometry("460x460")  # ‚úÖ m√°s alta
        win.minsize(460, 460)
        win.grab_set()

        wrapper = ctk.CTkFrame(win, fg_color="transparent")
        wrapper.pack(fill="both", expand=True, padx=14, pady=14)
        wrapper.grid_columnconfigure(0, weight=1)

        ctk.CTkLabel(wrapper, text="Nombre", font=("Roboto", 12, "bold")).grid(row=0, column=0, sticky="w", pady=(0, 4))
        name_e = ctk.CTkEntry(wrapper)
        name_e.grid(row=1, column=0, sticky="ew")

        ctk.CTkLabel(wrapper, text="Rol", font=("Roboto", 12, "bold")).grid(row=2, column=0, sticky="w", pady=(12, 4))
        role_m = ctk.CTkOptionMenu(wrapper, values=["Operativa", "Ventas", "Administraci√≥n", "Direcci√≥n"])
        role_m.set("Operativa")
        role_m.grid(row=3, column=0, sticky="ew")

        ctk.CTkLabel(wrapper, text="‚Ç¨/hora", font=("Roboto", 12, "bold")).grid(row=4, column=0, sticky="w",
                                                                               pady=(12, 4))
        eur_e = ctk.CTkEntry(wrapper)
        eur_e.insert(0, "10")
        eur_e.grid(row=5, column=0, sticky="ew")

        msg = ctk.CTkLabel(wrapper, text="", text_color="#e74c3c")
        msg.grid(row=6, column=0, sticky="w", pady=(10, 0))

        spacer = ctk.CTkFrame(wrapper, fg_color="transparent")
        spacer.grid(row=7, column=0, sticky="nsew")
        wrapper.grid_rowconfigure(7, weight=1)

        btns = ctk.CTkFrame(wrapper, fg_color="transparent")
        btns.grid(row=8, column=0, sticky="ew", pady=(12, 0))
        btns.grid_columnconfigure(0, weight=1)
        btns.grid_columnconfigure(1, weight=1)

        def _ok():
            name = (name_e.get() or "").strip()
            role = (role_m.get() or "").strip()
            try:
                eur = float((eur_e.get() or "").strip())
            except:
                eur = -1

            if not name:
                msg.configure(text="Falta nombre.")
                return
            if eur <= 0:
                msg.configure(text="‚Ç¨/hora inv√°lido.")
                return

            color = self._adv_random_color()  # ‚úÖ random autom√°tico

            self.adv_users.append({
                "name": name,
                "role": role,
                "eur_per_hour": eur,
                "color": color,
                "ai_eff": None,  # 1..100 (lo pone IA)
                "ai_eff_day": None
            })

            self._adv_ensure_user_series(name, color)
            self._adv_refresh_users_box()
            self._adv_redraw_all_lines()

            # pedir score IA
            self._adv_request_ai_efficiency_async(name)

            # refrescar totals ya
            self._adv_refresh_totals()

            win.destroy()

        ctk.CTkButton(btns, text="Cancelar", fg_color="#34495e", command=win.destroy).grid(row=0, column=1, sticky="ew")
        ctk.CTkButton(btns, text="A√±adir", fg_color="#27ae60", command=_ok).grid(row=0, column=0, sticky="ew",
                                                                                 padx=(0, 10))

    def _adv_ensure_user_series(self, name: str, color: str):
        # dos l√≠neas: real + efectivo
        for suffix in ("real", "eff"):
            key = f"{name}:{suffix}"
            if key not in self.adv_data:
                self.adv_data[key] = {"x": [0], "y": [0.0]}

        # l√≠neas matplotlib (si ya existe ax)
        if self.adv_ax:
            if f"{name}:real" not in self.adv_lines:
                (ln,) = self.adv_ax.plot([0], [0], label=f"{name} ‚Ç¨ real", linewidth=2)
                ln.set_color(color)
                self.adv_lines[f"{name}:real"] = ln

            if f"{name}:eff" not in self.adv_lines:
                (ln2,) = self.adv_ax.plot([0], [0], label=f"{name} ‚Ç¨ efectivo", linewidth=2, linestyle="--")
                ln2.set_color(color)
                self.adv_lines[f"{name}:eff"] = ln2

            self.adv_ax.legend(loc="upper left", fontsize=9, facecolor="#1a1a1a", edgecolor="#444", labelcolor="white")

    def _adv_redraw_all_lines(self):
        if not (self.adv_ax and self.adv_canvas):
            return

        # reset l√≠mites x por horas
        self._adv_apply_axes_limits()

        # reinyectar series existentes
        for key, series in self.adv_data.items():
            ln = self.adv_lines.get(key)
            if ln:
                ln.set_data(series["x"], series["y"])

        # ajustar y max
        self._adv_autoscale_y()
        self.adv_canvas.draw_idle()

    def _adv_autoscale_y(self):
        if not self.adv_ax:
            return
        ymax = 0.0
        for series in self.adv_data.values():
            if series["y"]:
                ymax = max(ymax, max(series["y"]))
        if ymax <= 0:
            ymax = 1.0
        self.adv_ax.set_ylim(0, ymax * 1.12)

    def _adv_start_stop(self):
        # toggle
        if self.adv_running:
            self.adv_running = False
            try:
                if self.adv_btn_start:
                    self.adv_btn_start.configure(text="EMPEZAR")
            except:
                pass
            # cancelar job
            try:
                if self._adv_tick_job:
                    self.after_cancel(self._adv_tick_job)
                    self._adv_tick_job = None
            except:
                pass
            return

        # iniciar: validar horas
        try:
            h = float((self.adv_hours_entry.get() or "8").strip())
            if h <= 0:
                h = 8.0
        except:
            h = 8.0

        self.adv_total_seconds = int(h * 3600)
        self.adv_seconds = 0

        # reset series a 0
        for k in list(self.adv_data.keys()):
            self.adv_data[k] = {"x": [0], "y": [0.0]}
            if k in self.adv_lines:
                self.adv_lines[k].set_data([0], [0.0])

        self._adv_apply_axes_limits()
        self._adv_autoscale_y()
        if self.adv_canvas:
            self.adv_canvas.draw_idle()

        if not self.adv_users:
            # no arrancar sin usuarios
            return

        self.adv_running = True
        try:
            if self.adv_btn_start:
                self.adv_btn_start.configure(text="DETENER")
        except:
            pass

        # tick loop
        self._adv_tick()

    def _adv_tick(self):
        if not self.adv_running:
            return

        # ‚úÖ aceleraci√≥n: procesamos N segundos por frame para que ‚Äúcorra‚Äù r√°pido
        # Si quer√©s 1:1 real, ponelo en 1 (pero va a tardar)
        batch = 250  # segundos por tick (r√°pido y fluido)
        end = min(self.adv_total_seconds, self.adv_seconds + batch)

        for sec in range(self.adv_seconds + 1, end + 1):
            self._adv_step_one_second(sec)

        self.adv_seconds = end

        # redraw
        self._adv_redraw_all_lines()

        if self.adv_seconds >= self.adv_total_seconds:
            self.adv_running = False
            try:
                if self.adv_btn_start:
                    self.adv_btn_start.configure(text="EMPEZAR")
            except:
                pass
            return

        # siguiente tick
        self._adv_tick_job = self.after(30, self._adv_tick)

    def _adv_step_one_second(self, sec: int):
        # (opcional) muestreo para que no explote en puntos:
        # if sec % 10 != 0 and sec != self.adv_total_seconds:
        #     return

        for u in self.adv_users:
            name = (u.get("name") or "").strip()
            eur_h = float(u.get("eur_per_hour") or 0.0)
            cost_sec_real = eur_h / 3600.0

            # ‚úÖ KPI objetivo (FOCO) 0..1
            kpi_ratio = self._adv_get_user_kpi(name)  # 0..1
            kpi_pct = int(round(kpi_ratio * 100))

            # clamp igual que en _adv_user_cost_per_sec
            if kpi_pct < 20:
                kpi_pct = 20
            if kpi_pct > 100:
                kpi_pct = 100

            ratio = kpi_pct / 100.0
            cost_sec_eff = cost_sec_real / ratio  # efectivo = real / KPI

            kr = f"{name}:real"
            ke = f"{name}:eff"

            yr_prev = self.adv_data[kr]["y"][-1]
            ye_prev = self.adv_data[ke]["y"][-1]

            self.adv_data[kr]["x"].append(sec)
            self.adv_data[kr]["y"].append(yr_prev + cost_sec_real)

            self.adv_data[ke]["x"].append(sec)
            self.adv_data[ke]["y"].append(ye_prev + cost_sec_eff)

            if kr in self.adv_lines:
                self.adv_lines[kr].set_data(self.adv_data[kr]["x"], self.adv_data[kr]["y"])
            if ke in self.adv_lines:
                self.adv_lines[ke].set_data(self.adv_data[ke]["x"], self.adv_data[ke]["y"])

        self._adv_refresh_totals()

    def _adv_get_user_kpi(self, username: str) -> float:
        """
        KPI como ratio 0..1.
        - Si el usuario es el target_user actual: calcula desde self.history_raw (FOCO).
        - Si est√° en all_users_stats y trae 'raw': calcula desde ese raw.
        - Si no hay datos: fallback 0.80
        """
        # 1) si es el usuario actual
        try:
            if (username or "").strip() == (self.target_user or "").strip():
                stats = self.get_categorized_data()
                total = stats["Productivo"] + stats["Ocio"]
                if total > 0:
                    return max(0.0, min(1.0, stats["Productivo"] / total))
        except:
            pass

        # 2) buscar en all_users_stats raw
        try:
            for u in (self.all_users_stats or []):
                if not isinstance(u, dict):
                    continue
                name = u.get("name") or u.get("user") or u.get("username")
                if (name or "").strip() != (username or "").strip():
                    continue
                raw = u.get("raw")
                if isinstance(raw, str) and raw.strip():
                    kpi_pct = int(self._compute_kpi_from_raw_block(raw) or 0)
                    return max(0.0, min(1.0, kpi_pct / 100.0))
        except:
            pass

        return 0.80

    def _render_ai_chat_history(self):
        if not hasattr(self, "_ai_chat_scroll") or not self._ai_chat_scroll:
            return

        # limpiar contenedor
        try:
            for w in self._ai_chat_scroll.winfo_children():
                w.destroy()
        except:
            return

        ui = getattr(self, "_ai_ui", {}) or {}
        USER_BUBBLE = ui.get("USER_BUBBLE", "#16354a")
        ASSIST_BUBBLE = ui.get("ASSIST_BUBBLE", "#0f2436")
        USER_EDGE = ui.get("USER_EDGE", "#245a73")
        ASSIST_EDGE = ui.get("ASSIST_EDGE", "#1e3a55")
        TXT = ui.get("TXT", "white")
        MUT = ui.get("MUT", "#a9bfd8")

        # mostrar √∫ltimos N
        history = (self._ai_chat_history or [])[-60:]

        for role, text in history:
            text = (text or "").strip()
            if not text:
                continue

            row = ctk.CTkFrame(self._ai_chat_scroll, fg_color="transparent")
            row.pack(fill="x", pady=6)

            is_user = (role == "user")
            bubble_color = USER_BUBBLE if is_user else ASSIST_BUBBLE
            edge = USER_EDGE if is_user else ASSIST_EDGE

            bubble = ctk.CTkFrame(
                row,
                fg_color=bubble_color,
                corner_radius=14,
                border_width=1,
                border_color=edge
            )

            # alineaci√≥n
            if is_user:
                bubble.pack(anchor="e", padx=(70, 0))
            else:
                bubble.pack(anchor="w", padx=(0, 70))

            who = "JEFE" if is_user else "IA"
            ctk.CTkLabel(
                bubble,
                text=who,
                font=("Roboto", 10, "bold"),
                text_color=MUT
            ).pack(anchor="w", padx=10, pady=(8, 0))

            ctk.CTkLabel(
                bubble,
                text=text,
                font=("Roboto", 13),
                text_color=TXT,
                justify="left",
                wraplength=520
            ).pack(anchor="w", padx=10, pady=(4, 10))

    def _send_ai_chat_from_ui(self, force_last_user_message: bool = False):
        if not hasattr(self, "_ai_chat_entry") or not self._ai_chat_entry:
            return

        if force_last_user_message:
            # ya se agreg√≥ el mensaje al historial por fuera
            q = ""
            for role, msg in reversed(self._ai_chat_history):
                if role == "user" and (msg or "").strip():
                    q = msg.strip()
                    break
        else:
            try:
                q = (self._ai_chat_entry.get("1.0", "end") or "").strip()
            except:
                q = ""
            if not q:
                return
            try:
                self._ai_chat_entry.delete("1.0", "end")
            except:
                pass
            self._ai_chat_history.append(("user", q))
            self._render_ai_chat_history()

        user = (self.user_var.get() or self.target_user or "").strip()
        day = ""
        try:
            day = (self.ai_date_entry.get() or "").strip()
        except:
            pass

        context = self._build_ai_context(user=user, day=day)

        # mensaje "typing" neutro
        self._append_chat("assistant", "Procesando‚Ä¶")

        import threading
        threading.Thread(
            target=self._ai_chat_worker_pro,
            args=(q, context),
            daemon=True
        ).start()

    def _ai_chat_worker_pro(self, question: str, context: str):
        """
        Igual que tu worker, pero:
        - no devuelve errores crudos
        - reemplaza el "Procesando‚Ä¶" por la respuesta real
        """
        out_text = ""
        try:
            from openai import OpenAI
            client = OpenAI()

            system_prompt = (
                "Sos un asistente para un jefe que monitorea productividad en una agencia de viajes.\n"
                "Convert√≠ logs t√©cnicos a informaci√≥n clara y accionable.\n"
                "No inventes. Si falta informaci√≥n, decilo.\n"
                "Respond√© en espa√±ol profesional.\n"
                "No uses emojis.\n"
                "No uses decoraciones como * o **.\n"
            )

            user_input = (
                "Contexto disponible:\n"
                f"{context}\n\n"
                "Pregunta del jefe:\n"
                f"{question}\n\n"
                "Reglas:\n"
                "- Clasific√°: Productivo / Ocio / Riesgo / Incierto.\n"
                "- Fundament√° con datos observables (apps, tiempos, foco, inactividad).\n"
                "- Termin√° con acciones recomendadas para la empresa.\n"
            )

            resp = client.responses.create(
                model="gpt-4o-mini",
                input=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_input},
                ]
            )

            out_text = ""
            for item in getattr(resp, "output", []) or []:
                if getattr(item, "type", None) == "message":
                    for c in getattr(item, "content", []) or []:
                        if getattr(c, "type", None) in ("output_text", "text"):
                            out_text += getattr(c, "text", "")

            out_text = (out_text or "").strip()

        except Exception:
            out_text = "No pude responder en este momento. Prob√° de nuevo o verific√° la configuraci√≥n de la API."

        def ui():
            # borrar el √∫ltimo "Procesando‚Ä¶" si existe
            try:
                if self._ai_chat_history and self._ai_chat_history[-1][0] == "assistant" and self._ai_chat_history[-1][
                    1].startswith("Procesando"):
                    self._ai_chat_history.pop()
            except:
                pass

            self._ai_chat_history.append(("assistant", out_text or "Sin respuesta."))
            self._render_ai_chat_history()

        try:
            self.after(0, ui)
        except:
            ui()

    def _build_ai_context(self, user: str, day: str) -> str:
        # contexto principal: log IA recibido (si existe)
        log_txt = (self._ai_log_text or "").strip()

        # opcional: incluir un recorte del historial raw para m√°s contexto
        raw = (self.history_raw or "").strip()
        if len(raw) > 6000:
            raw = raw[-6000:]  # √∫ltimos 6000 chars

        meta = f"Usuario: {user}\nFecha: {day or '‚Äî'}\n"
        parts = [meta]

        if log_txt:
            # si es gigante, recortar
            if len(log_txt) > 12000:
                log_txt = log_txt[-12000:]
            parts.append("LOG IA (texto):\n" + log_txt)

        if raw:
            parts.append("\nHISTORIAL CRUDO (recorte):\n" + raw)

        return "\n\n".join(parts)

    def _ai_chat_worker(self, question: str, context: str):
        """
        Llama a OpenAI desde el cliente del jefe.
        Requiere: pip install openai
        y variable OPENAI_API_KEY en el entorno donde corre la app.
        """
        try:
            from openai import OpenAI
            client = OpenAI()

            system_prompt  = (
                "Sos un asistente para un jefe que monitorea actividad/productividad.\n"
                "Convert√≠ logs t√©cnicos a explicaci√≥n humana clara.\n"
                "No inventes: si falta informaci√≥n, decilo.\n"
                "Respond√© en espa√±ol y en formato pr√°ctico (bullets si ayuda).\n"
            )

            user_input = """
            Sos el Asistente de Production de una agencia de viajes profesional.
            Tu funci√≥n es ayudar al jefe a interpretar logs t√©cnicos, capturas de pantalla y registros de actividad de empleados,
            convirti√©ndolos en informaci√≥n clara, operativa y accionable.

            ================================================
            ROL
            ================================================
            Actu√°s como un analista senior de productividad y operaciones internas.
            No sos un coach emocional ni un polic√≠a: sos un evaluador t√©cnico y estrat√©gico.

            ================================================
            ESTILO DE RESPUESTA
            ================================================
            - Escrib√≠ SIEMPRE en espa√±ol claro y profesional.
            - Us√° t√≠tulos numerados y listas con vi√±etas.
            - S√© directo, concreto y accionable.
            - No inventes informaci√≥n: si algo no se ve, decilo expl√≠citamente.
            - No moralices ni juzgues: evalu√° desde lo operativo.
            - No uses emojis.
            -No uses * ni ** para decorar el texto no lo decores de ninguna forma

            ================================================
            OBJETIVO PRINCIPAL
            ================================================
            A partir de la informaci√≥n recibida:
            - Explicar QU√â est√° haciendo el empleado.
            - Determinar si su actividad es PRODUCTIVA, OCIO, RIESGO o INCIERTA.
            - Evaluar su nivel de eficiencia real.
            - Ayudar al jefe a tomar decisiones.

            ================================================
            TAREAS PRODUCTIVAS (AGENCIA DE VIAJES)
            ================================================
            Consider√° PRODUCTIVO, entre otras, las siguientes actividades:

            - Dise√±o de itinerarios
            - Cotizaci√≥n de viajes
            - Gesti√≥n de reservas
            - Contacto con proveedores
            - Emisi√≥n o revisi√≥n de vuelos
            - Uso de GDS, CRMs o backoffice
            - Uso de Excel / Sheets para c√°lculos
            - Edici√≥n de PDFs, presupuestos, itinerarios
            - Correos profesionales con clientes o proveedores
            - Investigaci√≥n de destinos, hoteles, vuelos
            - Coordinaci√≥n operativa
            - Preparaci√≥n de documentaci√≥n de viaje
            - Seguimiento post-venta
            - Revisi√≥n de incidencias
            - Organizaci√≥n de tareas internas

            Todo lo que tenga que ve ocn youtube o whatsapp no son tareas productivas.
            ================================================
            REGLA FINAL
            ================================================
            Us√° √öNICAMENTE la informaci√≥n recibida.
            Si algo no se puede determinar, indic√° ‚ÄúNo se puede inferir con el log actual‚Äù. 

            ===============================================
CONTEXTO DISPONIBLE
===============================================
{context}

===============================================
PREGUNTA DEL JEFE
===============================================
{question}

si son preguntas especificas sobre el historial o sobre subida de sueldos a eficiencia debes de responder lo mas honesto posible y
dando datos objetivos sobre el tema como aplciaciones que ha usado, no usado tiempo activo e inactivo y siempre tienes que responder
basandote en que es lo mejor para la empresa de viajes y caules son las funcionalidades de un empleado
            """ +  "\n\nCONTEXTO:\n" + str(context) + "\n\nPREGUNTA:\n" + str(question)

            resp = client.responses.create(
                model="gpt-4o-mini",
                input=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_input},
                ]
            )

            out_text = ""

            for item in getattr(resp, "output", []) or []:
                if getattr(item, "type", None) == "message":
                    for c in getattr(item, "content", []) or []:
                        c_type = getattr(c, "type", None)
                        if c_type in ("output_text", "text"):
                            out_text += getattr(c, "text", "")

            out_text = (out_text or "").strip() or "(Sin respuesta)"


        except Exception as e:
            out_text = f"(Error IA: {type(e).__name__}: {e})"

        def ui():
            self._ai_chat_history.append(("assistant", out_text))
            self._render_ai_chat_history()

        try:
            self.after(0, ui)
        except:
            ui()

    def set_ai_log_text(self, user: str, day: str, text: str):
        self._ai_log_meta = f"{user} ‚Äî {day}"
        self._ai_log_text = text or ""

        def ui():
            try:
                if hasattr(self, "_ai_meta_lbl") and self._ai_meta_lbl:
                    self._ai_meta_lbl.configure(text=self._ai_log_meta)
                if hasattr(self, "_ai_log_textbox") and self._ai_log_textbox:
                    self._ai_log_textbox.configure(state="normal")
                    self._ai_log_textbox.delete("1.0", "end")
                    self._ai_log_textbox.insert("1.0", self._ai_log_text or "(vac√≠o)")
                    self._ai_log_textbox.see("1.0")
                    self._ai_log_textbox.configure(state="disabled")
            except:
                pass

        try:
            self.after(0, ui)
        except:
            ui()

    def _on_pick_user(self, user):
        if not user or user == self.target_user:
            return
        self.target_user = user
        try:
            self.title_lbl.configure(text=f"RENDIMIENTO: {self.target_user}")
        except:
            pass
        if callable(self.on_change_user):
            try:
                self.on_change_user(user, self.selected_day)
            except TypeError:
                self.on_change_user(user)
        # re-render (por si el caller ya actualiz√≥ history_raw/tiempos)
        self._render_all_tabs()

    def _safe_setup(self, tab_name: str, fn):
        tab = self.tabview.tab(tab_name)
        for w in tab.winfo_children():
            w.destroy()
        try:
            fn()
        except Exception as e:
            ctk.CTkLabel(
                tab,
                text=f"ERROR en {tab_name}:\n{type(e).__name__}: {e}",
                text_color="#e74c3c",
                font=("Consolas", 12),
                justify="left"
            ).pack(padx=20, pady=20, anchor="w")
            print(f"[PerfView] ERROR en {tab_name}:", repr(e))

    # =========================
    # REFRESH robusto
    # =========================
    def _handle_refresh(self):
        """
        on_refresh puede:
        - no devolver nada -> re-render con lo actual
        - devolver dict con claves: active_time_str, inactive_time_str, history_raw, all_users_stats, user_list
        - devolver tuple/list (active_time_str, inactive_time_str, history_raw, all_users_stats, user_list)
        """
        payload = None
        if callable(self.on_refresh):
            try:
                payload = self.on_refresh()
            except Exception as e:
                print("[PerfView] on_refresh error:", repr(e))

        try:
            if isinstance(payload, dict):
                if "active_time_str" in payload:
                    self.active_sec = self.parse_time_to_seconds(payload.get("active_time_str"))
                if "inactive_time_str" in payload:
                    self.inactive_sec = self.parse_time_to_seconds(payload.get("inactive_time_str"))
                if "history_raw" in payload and payload.get("history_raw") is not None:
                    self.history_raw = payload.get("history_raw") or ""
                if "all_users_stats" in payload and payload.get("all_users_stats") is not None:
                    self.all_users_stats = payload.get("all_users_stats") or []
                if "user_list" in payload and payload.get("user_list") is not None:
                    self.user_list = payload.get("user_list") or []
                    self._refresh_user_menu_values()

            elif isinstance(payload, (list, tuple)) and len(payload) >= 3:
                active_time_str = payload[0]
                inactive_time_str = payload[1]
                history_raw = payload[2]
                all_users_stats = payload[3] if len(payload) >= 4 else None
                user_list = payload[4] if len(payload) >= 5 else None

                self.active_sec = self.parse_time_to_seconds(active_time_str)
                self.inactive_sec = self.parse_time_to_seconds(inactive_time_str)
                self.history_raw = history_raw or ""
                if all_users_stats is not None:
                    self.all_users_stats = all_users_stats or []
                if user_list is not None:
                    self.user_list = user_list or []
                    self._refresh_user_menu_values()
        except Exception as e:
            print("[PerfView] refresh payload parse error:", repr(e))

        self._render_all_tabs()

    def _refresh_user_menu_values(self):
        try:
            values = list(self.user_list) if self.user_list else []
            if self.target_user and self.target_user not in values:
                values = [self.target_user] + values
            if not values:
                values = [self.target_user] if self.target_user else ["---"]
            self.user_menu.configure(values=values)
            if self.target_user and self.target_user in values:
                self.user_menu.set(self.target_user)
            elif values:
                self.user_menu.set(values[0])

        except Exception as e:
            print("[PerfView] user_menu refresh error:", repr(e))

    # =========================
    # Extraer bloque TOP FOREGROUND (texto)
    # =========================
    def _extract_fg_history_text(self) -> str:
        text = self.history_raw or ""
        lines = [ln.rstrip("\n") for ln in text.split("\n")]
        fg_start = None
        for i, ln in enumerate(lines):
            if "TOP FOREGROUND" in ln:
                fg_start = i
                break
        if fg_start is None:
            return ""
        out_lines = []
        for ln in lines[fg_start:]:
            if "TOP BACKGROUND" in ln:
                break
            out_lines.append(ln)
        return "\n".join(out_lines).strip()

    # =========================
    # Parser robusto FOCO -> dict{name:sec}
    # =========================
    def _extract_focus_dict(self) -> dict:
        """
        Soporta TU formato real:
        USER_STATS|user|...|
        TOP FOREGROUND (en foco)
        ...
        > Algo | Titulo [0h 8m]
        ...
        TOP BACKGROUND ...
        """
        import re

        text = (self.history_raw or "")
        text = text.replace("\r", "")  # <- clave
        if not text.strip():
            return {}
        lines = [ln.strip("\n") for ln in text.split("\n")]

        # 0) Parser directo: l√≠neas tipo "> Nombre .... [0h 8m]"
        #    (sirve dentro o fuera del bloque)
        def parse_arrow_lines(src_lines):
            out_local = {}
            # acepta: > algo [0h 8m]  (con espacios raros)
            pat = re.compile(r"^\s*>\s*(.*?)\s*\[(.*?)\]\s*$")
            for ln in src_lines:
                m = pat.match(ln)
                if not m:
                    continue
                name = m.group(1).strip()
                dur = m.group(2).strip()
                sec = self._parse_duration_to_seconds(dur)
                if name and sec > 0:
                    out_local[name] = out_local.get(name, 0) + sec
            return out_local

        # 1) Intentar SOLO el bloque TOP FOREGROUND
        fg_start = None
        for i, ln in enumerate(lines):
            if "TOP FOREGROUND" in ln:
                fg_start = i
                break

        if fg_start is not None:
            fg_lines = []
            for ln in lines[fg_start + 1:]:
                if "TOP BACKGROUND" in ln:
                    break
                # saltar separadores
                if ln.strip().startswith("-"):
                    continue
                if ln.strip() == "":
                    continue
                fg_lines.append(ln)

            out = parse_arrow_lines(fg_lines)
            if out:
                return out

        # 2) Fallback: si no encontr√≥ bloque, parsea todas las l√≠neas con ">"
        out = parse_arrow_lines(lines)
        if out:
            return out

        # 3) Legacy: ACTIVE> / ‚≠ê ... [0h 10m]
        out = {}
        for ln in lines:
            s = ln.strip()
            if s.startswith("ACTIVE>") or s.startswith("‚≠ê"):
                s2 = s.replace("ACTIVE>", "", 1).replace("‚≠ê", "", 1).strip()
                name = s2.split("[")[0].strip()
                dur = ""
                if "[" in s2 and "]" in s2:
                    dur = s2.split("[", 1)[1].split("]", 1)[0]
                sec = self._parse_duration_to_seconds(dur)
                if name and sec > 0:
                    out[name] = out.get(name, 0) + sec
        return out

    def _debug_history(self, tag=""):
        txt = (self.history_raw or "").replace("\r", "")
        print("\n=== PERF DEBUG", tag, "===")
        print("chars:", len(txt))
        ls = txt.splitlines()
        print("lines:", len(ls))
        for i, ln in enumerate(ls[:20], 1):
            print(f"{i:02d} | {ln}")
        print("contains TOP FOREGROUND:", ("TOP FOREGROUND" in txt))
        print("count lines starting with '>':", sum(1 for ln in ls if ln.strip().startswith(">")))

    # =========================
    # KPI (FOCO): Productivo vs Ocio
    # =========================
    def get_categorized_data(self):
        ocio_k = DISTRACTION_KEYWORDS
        data = self._extract_focus_dict()
        stats = {"Productivo": 0, "Ocio": 0}
        for name, sec in data.items():
            low = name.lower()
            if any(k in low for k in ocio_k):
                stats["Ocio"] += sec
            else:
                stats["Productivo"] += sec
        return stats

    def _split_focus_by_category(self):
        """Devuelve (prod_dict, ocio_dict)"""
        ocio_k = DISTRACTION_KEYWORDS
        data = self._extract_focus_dict()
        prod = {}
        ocio = {}
        for name, sec in data.items():
            low = name.lower()
            if any(k in low for k in ocio_k):
                ocio[name] = ocio.get(name, 0) + sec
            else:
                prod[name] = prod.get(name, 0) + sec
        return prod, ocio

    # =========================
    # TAB: Scoreboard
    # =========================
    def _coerce_active_sec(self, user: dict) -> int:
        # soporta distintas claves
        if not isinstance(user, dict):
            return 0
        if isinstance(user.get("active_sec"), (int, float)):
            return int(user.get("active_sec", 0))
        if isinstance(user.get("active"), (int, float)):
            return int(user.get("active", 0))
        if user.get("active_time_str"):
            return self.parse_time_to_seconds(user.get("active_time_str"))
        if user.get("active_time"):
            # puede venir como "0h 12m" o segundos
            v = user.get("active_time")
            if isinstance(v, (int, float)):
                return int(v)
            return self.parse_time_to_seconds(v)
        return 0

    def _coerce_efficiency(self, user: dict) -> int:
        if not isinstance(user, dict):
            return 0
        # acepta efficiency, kpi, efficiency_pct
        for k in ("efficiency", "kpi", "efficiency_pct"):
            v = user.get(k, None)
            if isinstance(v, (int, float)):
                return int(v)
            if isinstance(v, str) and v.strip().endswith("%"):
                try:
                    return int(float(v.strip().replace("%", "")))
                except:
                    pass
        return 0

    def setup_scoreboard(self, sort_by="active"):
        # ‚úÖ recordamos el √∫ltimo orden elegido
        self._score_sort = sort_by

        tab_target = self.tabview.tab("Scoreboard Global")
        for widget in tab_target.winfo_children():
            widget.destroy()

        top = ctk.CTkFrame(tab_target, fg_color="transparent")
        top.pack(fill="x", padx=20, pady=10)

        ctk.CTkLabel(
            top,
            text="RANKING GLOBAL",
            font=("Roboto", 16, "bold"),
            text_color="#f1c40f"
        ).pack(side="left")

        btn_f = ctk.CTkFrame(top, fg_color="transparent")
        btn_f.pack(side="right")

        ctk.CTkButton(
            btn_f, text="TIEMPO", width=80,
            command=lambda: self.setup_scoreboard("active")
        ).pack(side="right", padx=3)

        ctk.CTkButton(
            btn_f, text="KPI", width=80,
            command=lambda: self.setup_scoreboard("kpi")
        ).pack(side="right", padx=3)

        # ‚úÖ usar datos desde self.all_users_stats (si no existe, lista vac√≠a)
        # ‚úÖ usar datos desde self.all_users_stats (si no existe, lista vac√≠a)
        # ‚úÖ Bot√≥n SIEMPRE visible para poder pedir datos
        ctk.CTkButton(
            btn_f, text="CARGAR", width=90,
            command=self._on_click_load_all
        ).pack(side="right", padx=6)

        # ‚úÖ usar datos desde self.all_users_stats (si no existe, lista vac√≠a)
        stats_src = getattr(self, "all_users_stats", None)
        if not stats_src:
            ctk.CTkLabel(
                tab_target,
                text="Sin datos todav√≠a. Toc√° CARGAR para pedir el ranking.",
                text_color="gray"
            ).pack(pady=20)
            return
            if callable(self.on_load_all):
                self.after(200, self._on_click_load_all)

        # ---------------------------------------------------------
        # ‚úÖ Normalizaci√≥n ultra-robusta
        # Acepta:
        # - [{"name":"A", "fg_time":"01:22:10", "efficiency":70}, ...]
        # - [{"user":"A", "active_sec":1234, "kpi":55}, ...]
        # ---------------------------------------------------------
        normalized = []

        for u in stats_src:
            if not isinstance(u, dict):
                continue

            name = (
                    u.get("name")
                    or u.get("user")
                    or u.get("username")
                    or u.get("employee")
                    or "---"
            )

            # üü¶ ACTIVE TIME
            # intentamos sacar active_sec de m√∫ltiples formatos
            active_sec = 0

            if "active_sec" in u and isinstance(u.get("active_sec"), (int, float)):
                active_sec = int(u.get("active_sec") or 0)

            elif "fg_sec" in u and isinstance(u.get("fg_sec"), (int, float)):
                active_sec = int(u.get("fg_sec") or 0)


            elif "fg_time" in u and isinstance(u.get("fg_time"), str):

                fg = (u.get("fg_time") or "").strip()

                if ":" in fg:

                    active_sec = self._time_str_to_seconds(fg)  # "HH:MM:SS"

                else:

                    active_sec = self.parse_time_to_seconds(fg)  # "0d 0h 0m" / "0h 0m"


            elif "active_time" in u and isinstance(u.get("active_time"), str):
                active_sec = self._time_str_to_seconds(u.get("active_time"))

            else:
                # fallback: si existe tu coercer viejo, √∫salo
                try:
                    active_sec = self._coerce_active_sec(u)
                except Exception:
                    active_sec = 0

            # üü© KPI / EFFICIENCY
            eff = 0
            if "efficiency" in u and isinstance(u.get("efficiency"), (int, float)):
                eff = int(u.get("efficiency") or 0)
            elif "kpi" in u and isinstance(u.get("kpi"), (int, float)):
                eff = int(u.get("kpi") or 0)
            else:
                try:
                    eff = int(self._coerce_efficiency(u) or 0)
                except Exception:
                    eff = 0

            # ‚úÖ fallback: si no vino KPI/efficiency, calcularlo desde el raw del usuario
            if (eff <= 0) and isinstance(u.get("raw"), str) and u.get("raw").strip():
                try:
                    eff = int(self._compute_kpi_from_raw_block(u.get("raw")) or 0)
                except Exception:
                    eff = 0

            # clamp
            if eff < 0:
                eff = 0
            if eff > 100:
                eff = 100

            normalized.append({
                "name": name,
                "active_sec": active_sec,
                "efficiency": eff,
            })

        if not normalized:
            ctk.CTkLabel(
                tab_target,
                text="Sin datos normalizados.",
                text_color="gray"
            ).pack(pady=20)
            return

        # ‚úÖ Orden
        if sort_by == "active":
            sorted_u = sorted(normalized, key=lambda x: x.get("active_sec", 0), reverse=True)
        else:
            sorted_u = sorted(normalized, key=lambda x: x.get("efficiency", 0), reverse=True)

        container = ctk.CTkScrollableFrame(tab_target, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=10, pady=(0, 10))

        # ‚úÖ Header opcional
        header = ctk.CTkFrame(container, fg_color="transparent")
        header.pack(fill="x", padx=5, pady=(0, 6))

        ctk.CTkLabel(header, text="#", width=40, text_color="gray").pack(side="left", padx=6)
        ctk.CTkLabel(header, text="Empleado", width=220, anchor="w", text_color="gray").pack(side="left")
        ctk.CTkLabel(header, text="KPI", width=120, anchor="e", text_color="gray").pack(side="right", padx=14)
        ctk.CTkLabel(header, text="Tiempo Activo", width=130, anchor="e", text_color="gray").pack(side="right", padx=10)

        for i, user in enumerate(sorted_u, 1):
            is_target = (user.get("name") == getattr(self, "target_user", None))

            row = ctk.CTkFrame(
                container,
                fg_color="#34495e" if is_target else "#1e1e1e",
                height=46
            )
            row.pack(fill="x", pady=2, padx=5)
            row.pack_propagate(False)

            ctk.CTkLabel(
                row, text=f"{i}", width=40,
                font=("Roboto", 12, "bold"),
                text_color="#f1c40f"
            ).pack(side="left", padx=6)

            ctk.CTkLabel(
                row,
                text=user.get("name", "---"),
                width=220,
                anchor="w",
                font=("Roboto", 12, "bold") if is_target else ("Roboto", 12),
                text_color="white"
            ).pack(side="left")

            time_text = self.format_seconds(int(user.get("active_sec", 0) or 0))
            ctk.CTkLabel(
                row,
                text=time_text,
                font=("Consolas", 12),
                text_color="white",
                width=130
            ).pack(side="right", padx=10)

            eff = int(user.get("efficiency", 0) or 0)
            ctk.CTkLabel(
                row,
                text=f"{eff}% KPI",
                text_color="#2ecc71" if eff >= 70 else "#e74c3c",
                font=("Roboto", 12, "bold"),
                width=120,
                anchor="e"
            ).pack(side="right", padx=14)

    def _on_click_load_all(self):
        if callable(self.on_load_all):
            self.on_load_all()

    def _compute_kpi_from_raw_block(self, raw_block: str) -> int:
        """
        Calcula KPI (%) a partir del bloque 'raw' (USER_STATS...),
        sumando tiempos por app y clasificando con DISTRACTION_KEYWORDS.
        KPI = productivo / (productivo + ocio) * 100
        """
        if not isinstance(raw_block, str) or not raw_block.strip():
            return 0

        prod_sec = 0
        ocio_sec = 0

        for line in raw_block.splitlines():
            line = line.strip()
            if not line:
                continue

            # Ej: "> Chrome | Kclient | Trello           [0h 0m]"
            m = re.search(r"\[([^\]]+)\]", line)
            if not m:
                continue

            t_str = m.group(1).strip()
            try:
                sec = int(self.parse_time_to_seconds(t_str) or 0)
            except Exception:
                sec = 0
            if sec <= 0:
                continue

            app_name = line.split("[", 1)[0].replace(">", "").strip()
            low = app_name.lower()

            if any(k in low for k in DISTRACTION_KEYWORDS):
                ocio_sec += sec
            else:
                prod_sec += sec

        total = prod_sec + ocio_sec
        if total <= 0:
            return 0

        return int(round((prod_sec / total) * 100))

    def _time_str_to_seconds(self, s):
        # acepta "HH:MM:SS" o "MM:SS" o "SS"
        try:
            s = (s or "").strip()
            if not s:
                return 0
            parts = s.split(":")
            parts = [int(p) for p in parts]
            if len(parts) == 3:
                h, m, sec = parts
                return h * 3600 + m * 60 + sec
            if len(parts) == 2:
                m, sec = parts
                return m * 60 + sec
            if len(parts) == 1:
                return int(parts[0])
            return 0
        except Exception:
            return 0

    # =========================
    # TAB: Actividad vs Inactividad
    # =========================
    def setup_pie_chart(self):
        tab = self.tabview.tab("Actividad vs Inactividad")
        for widget in tab.winfo_children():
            widget.destroy()

        # figura
        fig, ax = plt.subplots(figsize=(3, 2), dpi=100)
        fig.patch.set_facecolor('#1a1a1a')
        ax.set_facecolor('#1a1a1a')

        val_activo = self.active_sec
        val_inactivo = self.inactive_sec

        if val_activo < 1 and val_inactivo < 1:
            ax.pie([1], labels=['Esperando datos...'], colors=['#333333'], textprops={'color': "gray"})
        else:
            ax.pie(
                [val_activo, val_inactivo],
                labels=['Activo', 'Inactivo'],
                autopct='%1.1f%%',
                colors=['#2ecc71', '#e74c3c'],
                textprops={'color': "w", 'weight': 'bold'},
                startangle=90,
                explode=(0.05, 0)
            )
        ax.set_title("PROPORCI√ìN DE ACTIVIDAD", color='white', pad=20, fontweight='bold')

        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)
        chart_holder = ctk.CTkFrame(self, width=900, height=320)
        chart_holder.pack(fill="x", padx=10, pady=10)  # NO expand
        chart_holder.pack_propagate(False)  # ‚úÖ evita que se achique

        canvas = FigureCanvasTkAgg(fig, master=chart_holder)
        w = canvas.get_tk_widget()
        w.pack(fill="both", expand=True)  # expand SOLO dentro del holder fijo

        # guardar refs para evitar GC
        self.pie_fig = fig
        self.pie_canvas = canvas

    # =========================
    # TAB: Top 3 (FOCO)
    # =========================
    def setup_bar_chart(self):
        tab = self.tabview.tab("Top 3 (FOCO)")
        for w in tab.winfo_children():
            w.destroy()

        data = self._extract_focus_dict()
        items = sorted(data.items(), key=lambda x: x[1], reverse=True)[:3]

        if not items:
            self._debug_history("TOP3")

            ctk.CTkLabel(tab, text="Sin datos de FOCO en el historial.", text_color="gray").pack(pady=20)
            return

        labels = [a[:32] for a, _ in items]
        hours = [(sec / 3600.0) for _, sec in items]

        fig, ax = plt.subplots(figsize=(6, 4), dpi=100)
        fig.patch.set_facecolor('#1a1a1a')
        ax.set_facecolor('#1a1a1a')
        ax.bar(labels, hours, color='#3498db')
        ax.set_title("TOP 3 EN FOCO (HORAS)", color='white', pad=20)
        ax.tick_params(colors='white')
        for s in ax.spines.values():
            s.set_color('#444')
        ax.set_ylabel("Horas", color="white")
        ax.set_xticks(range(len(labels)))
        ax.set_xticklabels(labels, rotation=15, ha="right", color="white")

        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)

        self.bar_fig = fig
        self.bar_canvas = canvas
        chart_holder = ctk.CTkFrame(self, width=900, height=320)
        chart_holder.pack(fill="x", padx=10, pady=10)  # NO expand
        chart_holder.pack_propagate(False)  # ‚úÖ evita que se achique

        canvas = FigureCanvasTkAgg(fig, master=chart_holder)
        w = canvas.get_tk_widget()
        w.pack(fill="both", expand=True)  # expand SOLO dentro del holder fijo

    # =========================
    # TAB: Comparador
    # =========================
    def setup_custom_chart(self):
        tab = self.tabview.tab("Comparador")
        for w in tab.winfo_children():
            w.destroy()

        self.all_apps_data = self._extract_focus_dict()
        self.selected_apps_to_compare = {}

        top_ctrl = ctk.CTkFrame(tab, fg_color="transparent")
        top_ctrl.pack(pady=10, fill="x", padx=10)

        values = list(self.all_apps_data.keys())
        if not values:
            values = ["---"]

        self.comp_menu = ctk.CTkOptionMenu(top_ctrl, values=values, width=420)
        self.comp_menu.pack(side="left", padx=10)

        ctk.CTkButton(
            top_ctrl, text="A√ëADIR +", command=self.add_factor,
            fg_color="#27ae60", width=110
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            top_ctrl, text="LIMPIAR", command=self.clear_factors,
            fg_color="#e74c3c", width=90
        ).pack(side="left", padx=5)

        self.lbl_added = ctk.CTkLabel(tab, text="Factores: Ninguno")
        self.lbl_added.pack(pady=(0, 6))

        fig, ax = plt.subplots(figsize=(6, 4), dpi=100)
        fig.patch.set_facecolor('#1a1a1a')
        ax.set_facecolor('#1a1a1a')
        ax.text(0.5, 0.5, "A√±ad√≠ factores arriba", color="white", ha="center", va="center")

        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)

        self.custom_fig = fig
        self.custom_ax = ax
        self.custom_canvas = canvas
        chart_holder = ctk.CTkFrame(self, width=900, height=320)
        chart_holder.pack(fill="x", padx=10, pady=10)  # NO expand
        chart_holder.pack_propagate(False)  # ‚úÖ evita que se achique

        canvas = FigureCanvasTkAgg(fig, master=chart_holder)
        w = canvas.get_tk_widget()
        w.pack(fill="both", expand=True)  # expand SOLO dentro del holder fijo

    def add_factor(self):
        app = self.comp_menu.get()
        if app in self.all_apps_data:
            self.selected_apps_to_compare[app] = self.all_apps_data[app]
            self.lbl_added.configure(text=f"Factores: {', '.join(self.selected_apps_to_compare.keys())}")
            self.update_custom_pie()

    def clear_factors(self):
        self.selected_apps_to_compare = {}
        self.lbl_added.configure(text="Factores: Ninguno")
        if self.custom_ax is not None and self.custom_canvas is not None:
            self.custom_ax.clear()
            self.custom_ax.set_facecolor('#1a1a1a')
            self.custom_ax.text(0.5, 0.5, "A√±ad√≠ factores arriba", color="white", ha="center", va="center")
            self.custom_canvas.draw()

    def update_custom_pie(self):
        if self.custom_ax is None or self.custom_canvas is None:
            return

        self.custom_ax.clear()
        self.custom_ax.set_facecolor('#1a1a1a')

        labels = list(self.selected_apps_to_compare.keys())
        sizes = list(self.selected_apps_to_compare.values())

        # ‚ÄúOtros‚Äù vs activo
        others = max(0, int(self.active_sec) - int(sum(sizes)))
        if others > 0:
            labels.append("Otros")
            sizes.append(others)

        if not sizes or sum(sizes) == 0:
            self.custom_ax.text(0.5, 0.5, "Sin datos", color="white", ha="center", va="center")
        else:
            self.custom_ax.pie(
                sizes,
                labels=[l[:28] for l in labels],
                autopct='%1.1f%%',
                textprops={'color': "w"},
                startangle=90
            )

        self.custom_canvas.draw()

    # =========================
    # TAB: KPI (FOCO)
    # =========================
    def setup_quality_chart(self):
        tab = self.tabview.tab("KPI (FOCO)")
        for w in tab.winfo_children():
            w.destroy()

        stats = self.get_categorized_data()
        total = stats["Productivo"] + stats["Ocio"]
        kpi = int((stats["Productivo"] / total) * 100) if total > 0 else 0

        # Header KPI
        head = ctk.CTkFrame(tab, fg_color="transparent")
        head.pack(fill="x", padx=14, pady=(12, 6))

        ctk.CTkLabel(
            head,
            text=f"KPI (FOCO): {kpi}%",
            font=("Roboto", 18, "bold"),
            text_color="#2ecc71" if kpi >= 70 else "#e74c3c"
        ).pack(side="left")

        ctk.CTkLabel(
            head,
            text=f"  Productivo: {self.format_seconds(stats['Productivo'])}   |   Ocio: {self.format_seconds(stats['Ocio'])}",
            font=("Consolas", 12),
            text_color="white"
        ).pack(side="left", padx=12)

        fig, ax = plt.subplots(figsize=(6, 4), dpi=100)
        fig.patch.set_facecolor('#1a1a1a')
        ax.set_facecolor('#1a1a1a')

        vals = [stats["Productivo"], stats["Ocio"]]
        if sum(vals) == 0:
            ax.text(0.5, 0.5, "Sin datos", color="white", ha="center", va="center")
        else:
            ax.pie(
                vals,
                labels=["Productivo", "Ocio"],
                autopct='%1.1f%%',
                colors=['#2ecc71', '#e74c3c'],
                textprops={'color': "w"},
                startangle=90,
                wedgeprops=dict(width=0.4)
            )
        ax.set_title("CALIDAD DE TRABAJO (KPI - FOCO)", color="white")

        canvas = FigureCanvasTkAgg(fig, master=tab)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)

        self.kpi_fig = fig
        self.kpi_canvas = canvas

    # =========================
    # TAB: Tabla Apps (FOCO) + buscador
    # =========================

    # =========================
    # Restricciones locales (solo en el cliente del Jefe)
    # - Se guardan en AppData para que persistan entre reinicios
    # =========================
    def _restrictions_path(self) -> str:
        try:
            base = get_appdata_base_dir()
        except Exception:
            base = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(base, "restricted_apps.json")

    def _norm_app_key(self, name: str) -> str:
        """
        Key estable por app/ventana.
        - NO colapsa todo a 'chrome'
        - Limpia prefijos inestables tipo "(22) "
        - Recorta largo para que sea guardable
        """
        n = (name or "").strip()
        if not n:
            return ""

        n = " ".join(n.split())  # normaliza espacios
        low = n.lower()

        # Si viene con separadores tipo: "Chrome | (22) YouTube"
        if "|" in n:
            parts = [p.strip() for p in n.split("|") if p.strip()]
            app = parts[0].lower()

            # resto (t√≠tulo de pesta√±a/ventana)
            rest = " | ".join(parts[1:]).strip()

            # limpia prefijo "(22) " o "(3) "
            import re
            rest = re.sub(r"^\(\d+\)\s*", "", rest).strip()

            # tambi√©n limpia repeticiones tipo " - Google Chrome" al final
            rest = re.sub(r"\s*-\s*google\s+chrome\s*$", "", rest, flags=re.IGNORECASE).strip()

            # key final (estable pero espec√≠fica)
            key = f"{app}||{rest}".strip().lower()

            # recorte por seguridad (evita json gigante)
            return key[:160]

        # Si NO hay "|", usamos el nombre entero normalizado
        return low[:160]

    def _load_restricted_apps(self):
        path = self._restrictions_path()
        try:
            if os.path.exists(path):
                with open(path, "r", encoding="utf-8") as f:
                    raw = json.load(f)
                if isinstance(raw, list):
                    return set(self._norm_app_key(x) for x in raw if str(x).strip())
                if isinstance(raw, dict):
                    # soporte legacy: {"apps":[...]}
                    arr = raw.get("apps", [])
                    if isinstance(arr, list):
                        return set(self._norm_app_key(x) for x in arr if str(x).strip())
        except Exception:
            pass
        return set()

    def _save_restricted_apps(self):
        path = self._restrictions_path()
        try:
            os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
            with open(path, "w", encoding="utf-8") as f:
                json.dump(sorted(list(getattr(self, "restricted_apps", set()))), f, ensure_ascii=False, indent=2)
        except Exception as e:
            print("save restricted apps error:", e)

    def is_restricted_app(self, name: str) -> bool:
        key = self._norm_app_key(name)
        if not key:
            return False

        s = getattr(self, "restricted_apps", None)
        if s is None:
            self.restricted_apps = self._load_restricted_apps()
            s = self.restricted_apps

        return key in s

    def toggle_restricted_app(self, name: str) -> bool:
        key = self._norm_app_key(name)
        if not key:
            return False

        if getattr(self, "restricted_apps", None) is None:
            self.restricted_apps = self._load_restricted_apps()

        if key in self.restricted_apps:
            self.restricted_apps.remove(key)
            active = False
        else:
            self.restricted_apps.add(key)
            active = True

        self._save_restricted_apps()
        return active

    def setup_table_tab(self):
        tab = self.tabview.tab("Tabla Apps (FOCO)")
        for w in tab.winfo_children():
            w.destroy()

        top = ctk.CTkFrame(tab, fg_color="transparent")
        top.pack(fill="x", padx=14, pady=10)

        ctk.CTkLabel(top, text="BUSCAR:", font=("Roboto", 12, "bold")).pack(side="left", padx=(0, 8))

        self.search_entry = ctk.CTkEntry(top, placeholder_text="chrome, excel, whatsapp...", width=280)
        self.search_entry.pack(side="left")
        self.search_entry.bind("<KeyRelease>", lambda e: self._refresh_table())

        self.limit_menu = ctk.CTkOptionMenu(
            top,
            values=["Top 25", "Top 50", "Todo"],
            width=110,
            command=lambda _: self._refresh_table()
        )
        self.limit_menu.set("Top 25")
        self.limit_menu.pack(side="left", padx=10)

        self.category_menu = ctk.CTkOptionMenu(
            top,
            values=["Todos", "Productivo", "Ocio"],
            width=130,
            command=lambda _: self._refresh_table()
        )
        self.category_menu.set("Todos")
        self.category_menu.pack(side="left", padx=10)

        ctk.CTkButton(
            top,
            text="REFRESCAR",
            width=120,
            fg_color="#34495e",
            command=self._refresh_table
        ).pack(side="right")

        self.table_frame = ctk.CTkScrollableFrame(tab, fg_color="#141414")
        self.table_frame.pack(fill="both", expand=True, padx=14, pady=(0, 14))

        self._refresh_table()

    def _refresh_table(self):
        if not hasattr(self, "table_frame"):
            return

        for w in self.table_frame.winfo_children():
            w.destroy()

        data = self._extract_focus_dict()
        if not data:
            self._debug_history("TOP3")

            ctk.CTkLabel(self.table_frame, text="Sin datos de FOCO en el historial.", text_color="gray").pack(pady=20)
            return

        items = sorted(data.items(), key=lambda x: x[1], reverse=True)

        q = (self.search_entry.get() if hasattr(self, "search_entry") else "").strip().lower()
        if q:
            items = [(n, s) for (n, s) in items if q in n.lower()]

        cat = self.category_menu.get() if hasattr(self, "category_menu") else "Todos"
        if cat != "Todos":
            ocio_k = DISTRACTION_KEYWORDS

            if cat == "Ocio":
                items = [(n, s) for (n, s) in items
                         if self.is_restricted_app(n) or any(k in n.lower() for k in ocio_k)]

            elif cat == "Productivo":
                items = [(n, s) for (n, s) in items
                         if (not self.is_restricted_app(n)) and (not any(k in n.lower() for k in ocio_k))]

        lim = self.limit_menu.get() if hasattr(self, "limit_menu") else "Top 25"
        if lim == "Top 25":
            items = items[:25]
        elif lim == "Top 50":
            items = items[:50]

        head = ctk.CTkFrame(self.table_frame, fg_color="#222")
        head.pack(fill="x", padx=6, pady=(6, 2))

        ctk.CTkLabel(
            head, text="APP / VENTANA (FOCO)", anchor="w",
            width=780, font=("Roboto", 12, "bold")
        ).pack(side="left", padx=10)

        head = ctk.CTkFrame(self.table_frame, fg_color="#222")
        head.pack(fill="x", padx=6, pady=(6, 2))
        head.grid_columnconfigure(0, weight=1)

        ctk.CTkLabel(head, text="APP / VENTANA (FOCO)", anchor="w",
                     font=("Roboto", 12, "bold")).grid(row=0, column=0, sticky="w", padx=10, pady=6)

        ctk.CTkLabel(head, text="TIEMPO", width=140,
                     font=("Roboto", 12, "bold"), anchor="e").grid(row=0, column=1, sticky="e", padx=10, pady=6)

        ctk.CTkLabel(head, text="RESTR", width=70,
                     font=("Roboto", 12, "bold"), anchor="e").grid(row=0, column=2, sticky="e", padx=6, pady=6)

        ctk.CTkLabel(head, text="ACC", width=44,
                     font=("Roboto", 12, "bold"), anchor="e").grid(row=0, column=3, sticky="e", padx=(6, 10), pady=6)

        for name, sec in items:
            low = (name or "").lower()

            is_restricted = self.is_restricted_app(name)
            is_ocio = is_restricted or any(k in low for k in DISTRACTION_KEYWORDS)

            row = ctk.CTkFrame(self.table_frame, fg_color="#1b1b1b")
            row.pack(fill="x", padx=6, pady=2)
            row.grid_columnconfigure(0, weight=1)

            # Nombre
            ctk.CTkLabel(row, text=name[:140], anchor="w").grid(
                row=0, column=0, sticky="w", padx=(10, 6), pady=8
            )

            # Tiempo
            ctk.CTkLabel(
                row, text=self.format_seconds(sec),
                width=140, font=("Consolas", 12), anchor="e"
            ).grid(row=0, column=1, sticky="e", padx=10, pady=8)

            # Estado
            badge_text = "RESTR" if is_restricted else ("OCIO" if is_ocio else "PROD")
            badge_color = "#e74c3c" if is_ocio else "#2ecc71"

            ctk.CTkLabel(
                row,
                text=badge_text,
                width=70,
                text_color=badge_color,
                font=("Roboto", 11, "bold"),
                anchor="e"
            ).grid(row=0, column=2, sticky="e", padx=(6, 6), pady=8)

            # Bot√≥n rojo (toggle)
            def _toggle(n=name):
                try:
                    self.toggle_restricted_app(n)
                    self._refresh_table()
                except Exception as e:
                    print("toggle restriction error:", e)

            ctk.CTkButton(
                row,
                text="üö´" if not is_restricted else "‚úÖ",
                width=44,
                fg_color="#b23b3b",
                hover_color="#8f2e2e",
                text_color="white",
                command=_toggle
            ).grid(row=0, column=3, sticky="e", padx=(6, 10), pady=6)

    # =========================
    # TAB: Historial crudo
    # =========================
    def setup_raw_history_tab(self):
        tab = self.tabview.tab("Historial Crudo")
        for w in tab.winfo_children():
            w.destroy()

        top = ctk.CTkFrame(tab, fg_color="transparent")
        top.pack(fill="x", padx=14, pady=10)

        ctk.CTkButton(
            top,
            text="IR ARRIBA",
            width=110,
            fg_color="#34495e",
            command=lambda: self.raw_txt.yview_moveto(0.0)
        ).pack(side="right", padx=6)

        ctk.CTkButton(
            top,
            text="IR ABAJO",
            width=110,
            fg_color="#34495e",
            command=lambda: self.raw_txt.yview_moveto(1.0)
        ).pack(side="right", padx=6)

        self.raw_txt = ctk.CTkTextbox(tab, fg_color="black", text_color="#00ff00", font=("Consolas", 11))
        self.raw_txt.pack(fill="both", expand=True, padx=14, pady=(0, 14))
        self.raw_txt.insert("1.0", self.history_raw or "")
        self.raw_txt.configure(state="disabled")
        self.raw_txt.yview_moveto(0.0)

    # =========================
    # Export PDF (MUCHO m√°s completo)
    # =========================
    def export_user_pdf(self):
        try:
            from fpdf import FPDF
            from datetime import datetime
            import os

            def clean_str(txt):
                return str(txt).encode("latin-1", "replace").decode("latin-1")

            # -------------------------
            # Datos
            # -------------------------
            focus = self._extract_focus_dict()
            prod_dict, ocio_dict = self._split_focus_by_category()
            stats = self.get_categorized_data()

            total_focus = stats["Productivo"] + stats["Ocio"]
            kpi = int((stats["Productivo"] / total_focus) * 100) if total_focus > 0 else 0

            unique_apps_total = len(focus)
            unique_ocio = len(ocio_dict)
            unique_prod = len(prod_dict)

            top_focus = sorted(focus.items(), key=lambda x: x[1], reverse=True)[:30]
            top_ocio = sorted(ocio_dict.items(), key=lambda x: x[1], reverse=True)[:20]
            top_prod = sorted(prod_dict.items(), key=lambda x: x[1], reverse=True)[:20]

            distraction_items_count = len(ocio_dict)

            ocio_pct = (stats["Ocio"] / total_focus * 100) if total_focus > 0 else 0.0
            prod_pct = (stats["Productivo"] / total_focus * 100) if total_focus > 0 else 0.0

            active_vs_focus_note = ""
            if getattr(self, "active_sec", 0) > 0 and total_focus > 0:
                ratio = min(999, int((total_focus / self.active_sec) * 100))
                active_vs_focus_note = f"FOCO vs ACTIVO: {ratio}% (FOCO/ACTIVO)."

            # -------------------------
            # PDF (robusto ancho)
            # -------------------------
            pdf = FPDF(orientation="P", unit="mm", format="A4")
            pdf.set_margins(12, 12, 12)
            pdf.set_auto_page_break(auto=True, margin=12)
            pdf.add_page()

            EPW = pdf.w - pdf.l_margin - pdf.r_margin  # effective page width

            def setx():
                pdf.set_x(pdf.l_margin)

            def cell_full(h, txt, **kwargs):
                setx()
                pdf.cell(EPW, h, txt, **kwargs)

            def multi_full(h, txt, **kwargs):
                setx()
                pdf.multi_cell(EPW, h, txt, **kwargs)

            def line_full():
                y = pdf.get_y()
                pdf.line(pdf.l_margin, y, pdf.w - pdf.r_margin, y)

            def safe_ln(mm=2):
                pdf.ln(mm)
                setx()

            # -------------------------
            # Header / T√≠tulo
            # -------------------------
            pdf.set_font("Arial", "B", 16)
            cell_full(10, clean_str(f"REPORTE DE RENDIMIENTO: {self.target_user}"), ln=True, align="C")

            safe_ln(2)
            pdf.set_font("Arial", "", 11)

            setx()
            # Dos columnas proporcionales al ancho √∫til (evita desbordes)
            w_left = int(EPW * 0.62)
            w_right = EPW - w_left
            pdf.cell(w_left, 7, clean_str(f"Fecha/Hora: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}"), ln=False)
            pdf.cell(w_right, 7, clean_str(f"KPI (FOCO): {kpi}%"), ln=True, align="R")

            pdf.set_draw_color(120, 120, 120)
            line_full()
            safe_ln(6)

            # =========================
            # 1) RESUMEN GENERAL
            # =========================
            pdf.set_font("Arial", "B", 12)
            cell_full(8, clean_str("1) Resumen general"), ln=True)

            pdf.set_font("Arial", "", 11)
            cell_full(7, clean_str(f"- Tiempo Activo (general): {self.format_seconds(self.active_sec)}"), ln=True)
            cell_full(7, clean_str(f"- Tiempo Inactivo (general): {self.format_seconds(self.inactive_sec)}"), ln=True)
            cell_full(7, clean_str(
                f"- Tiempo Productivo (FOCO): {self.format_seconds(stats['Productivo'])} ({prod_pct:.1f}%)"), ln=True)
            cell_full(7, clean_str(
                f"- Tiempo Ocio / Distracci√≥n (FOCO): {self.format_seconds(stats['Ocio'])} ({ocio_pct:.1f}%)"), ln=True)
            if active_vs_focus_note:
                cell_full(7, clean_str(f"- {active_vs_focus_note}"), ln=True)

            safe_ln(2)
            cell_full(7, clean_str(f"- Apps/Ventanas √∫nicas en FOCO: {unique_apps_total}"), ln=True)
            cell_full(7, clean_str(f"- √çtems Productivos √∫nicos: {unique_prod}"), ln=True)
            cell_full(7, clean_str(f"- √çtems Distracci√≥n √∫nicos: {unique_ocio}"), ln=True)
            cell_full(7, clean_str(
                f"- Cantidad de 'sitios/ventanas' marcados como distracci√≥n: {distraction_items_count}"), ln=True)

            safe_ln(3)
            pdf.set_font("Arial", "I", 10)
            if not focus:
                multi_full(5, clean_str(
                    "Nota: No se detectaron datos de FOCO en el historial. Revisa el formato enviado por el servidor."))
            else:
                multi_full(5, clean_str(
                    "Nota: El FOCO se construye a partir del historial recibido. Los porcentajes dependen de lo que el servidor reporte."))

            safe_ln(4)

            # =========================
            # 2) TOP FOCO
            # =========================
            pdf.set_font("Arial", "B", 12)
            cell_full(8, clean_str("2) Top FOCO (30)"), ln=True)

            # tabla 3 columnas (sum = EPW)
            w1 = int(EPW * 0.66)
            w2 = int(EPW * 0.18)
            w3 = EPW - w1 - w2

            pdf.set_font("Arial", "B", 10)
            pdf.set_fill_color(230, 230, 230)
            setx()
            pdf.cell(w1, 8, clean_str("Aplicaci√≥n / Ventana"), border=1, fill=True)
            pdf.cell(w2, 8, clean_str("Tiempo"), border=1, fill=True)
            pdf.cell(w3, 8, clean_str("Tipo"), border=1, fill=True, ln=True)

            pdf.set_font("Arial", "", 9)
            for name, sec in top_focus:
                low = str(name).lower()
                is_ocio = any(k in low for k in DISTRACTION_KEYWORDS)
                tipo = "OCIO" if is_ocio else "PROD"

                setx()
                pdf.cell(w1, 7, clean_str(str(name)[:70]), border=1)
                pdf.cell(w2, 7, clean_str(self.format_seconds(sec)), border=1)
                pdf.cell(w3, 7, clean_str(tipo), border=1, ln=True)

            safe_ln(4)

            # =========================
            # 3) TOP DISTRACTORES
            # =========================
            pdf.set_font("Arial", "B", 12)
            cell_full(8, clean_str("3) Top Distracciones (20)"), ln=True)

            if not top_ocio:
                pdf.set_font("Arial", "I", 10)
                cell_full(7, clean_str("No se detectaron distracciones (seg√∫n DISTRACTION_KEYWORDS)."), ln=True)
            else:
                wA = int(EPW * 0.74)
                wB = EPW - wA

                pdf.set_font("Arial", "B", 10)
                pdf.set_fill_color(230, 230, 230)
                setx()
                pdf.cell(wA, 8, clean_str("Sitio/App/Ventana (distracci√≥n)"), border=1, fill=True)
                pdf.cell(wB, 8, clean_str("Tiempo"), border=1, fill=True, ln=True)

                pdf.set_font("Arial", "", 9)
                for name, sec in top_ocio:
                    setx()
                    pdf.cell(wA, 7, clean_str(str(name)[:80]), border=1)
                    pdf.cell(wB, 7, clean_str(self.format_seconds(sec)), border=1, ln=True)

            safe_ln(4)

            # =========================
            # 4) TOP PRODUCTIVO
            # =========================
            pdf.set_font("Arial", "B", 12)
            cell_full(8, clean_str("4) Top Productivo (20)"), ln=True)

            if not top_prod:
                pdf.set_font("Arial", "I", 10)
                cell_full(7, clean_str("No se detect√≥ productivo (o no hay datos FOCO)."), ln=True)
            else:
                wA = int(EPW * 0.74)
                wB = EPW - wA

                pdf.set_font("Arial", "B", 10)
                pdf.set_fill_color(230, 230, 230)
                setx()
                pdf.cell(wA, 8, clean_str("App/Ventana (productivo)"), border=1, fill=True)
                pdf.cell(wB, 8, clean_str("Tiempo"), border=1, fill=True, ln=True)

                pdf.set_font("Arial", "", 9)
                for name, sec in top_prod:
                    setx()
                    pdf.cell(wA, 7, clean_str(str(name)[:80]), border=1)
                    pdf.cell(wB, 7, clean_str(self.format_seconds(sec)), border=1, ln=True)

            safe_ln(4)

            # =========================
            # 5) TOP FOREGROUND (extracto)
            # =========================
            fg_txt = self._extract_fg_history_text()
            pdf.set_font("Arial", "B", 12)
            cell_full(8, clean_str("5) TOP FOREGROUND (extracto)"), ln=True)

            if not fg_txt:
                pdf.set_font("Arial", "I", 10)
                cell_full(7, clean_str("No se encontr√≥ bloque TOP FOREGROUND en el historial."), ln=True)
            else:
                pdf.set_font("Courier", "", 8)
                fg_lines = fg_txt.splitlines()
                max_fg = 220
                if len(fg_lines) > max_fg:
                    fg_lines = fg_lines[:max_fg] + ["", "[... recortado ...]"]

                for line in fg_lines:
                    # multi_cell SIEMPRE con EPW y x reseteado
                    multi_full(4, clean_str(line))

            # =========================
            # 6) HISTORIAL COMPLETO (crudo - recortado)
            # =========================
            raw = (getattr(self, "history_raw", "") or "").strip()
            if raw:
                pdf.add_page()
                pdf.set_font("Arial", "B", 12)
                cell_full(8, clean_str("6) HISTORIAL COMPLETO (crudo - recortado)"), ln=True)

                pdf.set_font("Courier", "", 7)
                lines = raw.splitlines()
                max_lines = 900
                if len(lines) > max_lines:
                    lines = lines[:max_lines] + ["", "[... recortado ...]"]

                for line in lines:
                    multi_full(4, clean_str(line))

            # =========================
            # GUARDAR
            # =========================
            downloads_path = os.path.join(os.path.expanduser("~"), "Downloads")
            filename = f"Reporte_{self.target_user}.pdf"
            out_path = os.path.join(downloads_path, filename)
            pdf.output(out_path)

            messagebox.showinfo("√âxito", f"Reporte generado en Descargas:\n{filename}")

        except Exception as e:
            try:
                messagebox.showerror("Error PDF", f"Falla cr√≠tica: {e}")
            except Exception:
                pass


        except Exception as e:
            messagebox.showerror("Error PDF", f"Falla cr√≠tica: {e}")
import base64


class ScreenshotEditor(ctk.CTkFrame):
    """
    Editor simple de capturas:
    - Preview de la √∫ltima captura
    - Zoom +/- y zoom con rueda
    - Pan con click derecho (arrastrar)
    - Dibujo tipo subrayar/highlight
    - Goma/borrador
    - Undo / Clear
    - Guardar imagen anotada (PNG)
    """

    def __init__(self, master, width=520, height=240):
        super().__init__(master, fg_color="transparent")
        self.canvas = tk.Canvas(self, bg="#0c1522", highlightthickness=0, width=width, height=height)
        self.canvas.pack(fill="both", expand=True)

        # Estado imagen
        self._orig_pil: Optional[Image.Image] = None
        self._orig_path: Optional[str] = None
        self._scale = 1.0
        self._img_tk = None
        self._img_id = None

        # Estado dibujo
        self.mode = "highlight"   # "pen" | "highlight" | "eraser"
        self.pen_width = 3
        self.highlight_width = 18
        self.eraser_width = 22

        # strokes: lista de dicts con puntos en coords de imagen (NO canvas)
        self.strokes = []  # [{mode, width, color, points:[(x,y),...]}, ...]

        self._drawing = False
        self._current_points = []
        self._last_xy = None

        # Pan (click derecho)
        self.canvas.bind("<ButtonPress-3>", self._pan_start)
        self.canvas.bind("<B3-Motion>", self._pan_move)

        # Dibujo (click izq)
        self.canvas.bind("<ButtonPress-1>", self._draw_start)
        self.canvas.bind("<B1-Motion>", self._draw_move)
        self.canvas.bind("<ButtonRelease-1>", self._draw_end)

        # Zoom rueda (Windows)
        self.canvas.bind("<MouseWheel>", self._on_wheel)

        # Re-render cuando cambia tama√±o
        self.canvas.bind("<Configure>", lambda e: self._render())

        # Barra de herramientas (arriba)
        self.toolbar = ctk.CTkFrame(self, fg_color="transparent")
        self.toolbar.place(relx=0.0, rely=0.0, anchor="nw")

        self._build_toolbar()

    def _build_toolbar(self):
        # Botones compactos
        btn_cfg = dict(width=40, height=28, fg_color=CARD2, hover_color="#22324a")
        btn_cfg_ok = dict(width=70, height=28, fg_color=OK, hover_color="#27ae60")
        btn_cfg_warn = dict(width=70, height=28, fg_color=WARN, hover_color="#d4ac0d")

        ctk.CTkButton(self.toolbar, text="‚Äì", command=lambda: self.zoom_out(), **btn_cfg).pack(side="left", padx=3, pady=3)
        ctk.CTkButton(self.toolbar, text="+", command=lambda: self.zoom_in(), **btn_cfg).pack(side="left", padx=3, pady=3)
        ctk.CTkButton(self.toolbar, text="1:1", command=lambda: self.reset_zoom(), width=55, height=28,
                      fg_color=CARD2, hover_color="#22324a").pack(side="left", padx=3, pady=3)

        ctk.CTkButton(self.toolbar, text="HL", command=lambda: self.set_mode("highlight"), **btn_cfg_warn).pack(side="left", padx=(10, 3), pady=3)
        ctk.CTkButton(self.toolbar, text="‚úé", command=lambda: self.set_mode("pen"), **btn_cfg).pack(side="left", padx=3, pady=3)
        ctk.CTkButton(self.toolbar, text="‚å´", command=lambda: self.set_mode("eraser"), **btn_cfg).pack(side="left", padx=3, pady=3)

        ctk.CTkButton(self.toolbar, text="‚Ü∂", command=self.undo, **btn_cfg).pack(side="left", padx=(10, 3), pady=3)
        ctk.CTkButton(self.toolbar, text="Clear", command=self.clear, width=70, height=28,
                      fg_color="#c0392b", hover_color="#a93226").pack(side="left", padx=3, pady=3)

        ctk.CTkButton(self.toolbar, text="Save", command=self.save_annotated, **btn_cfg_ok).pack(side="left", padx=(10, 3), pady=3)

    # ----------------------------
    # Public API
    # ----------------------------
    def load_image_path(self, path: str):
        """
        Carga una imagen desde disco y la muestra.
        Resetea strokes (porque es "la √∫ltima captura").
        """
        try:
            img = Image.open(path)
            img.load()
        except Exception:
            return

        self._orig_pil = img.convert("RGBA")
        self._orig_path = path
        self._scale = 1.0
        self.strokes = []
        self._render()

    def set_mode(self, mode: str):
        if mode in ("pen", "highlight", "eraser"):
            self.mode = mode

    def zoom_in(self):
        self._scale = min(6.0, self._scale * 1.15)
        self._render()

    def zoom_out(self):
        self._scale = max(0.2, self._scale / 1.15)
        self._render()

    def reset_zoom(self):
        self._scale = 1.0
        self._render()

    def undo(self):
        if self.strokes:
            self.strokes.pop()
            self._render()

    def clear(self):
        self.strokes = []
        self._render()

    def save_annotated(self):
        """
        Guarda PNG anotado al lado del original o en cache.
        """
        if self._orig_pil is None:
            return

        base = self._orig_pil.copy()

        # Dibujar strokes sobre PIL
        from PIL import ImageDraw
        draw = ImageDraw.Draw(base)

        for s in self.strokes:
            pts = s["points"]
            if len(pts) < 2:
                continue

            if s["mode"] == "eraser":
                # "Borrar" pintando con el color del fondo no sirve en RGBA;
                # soluci√≥n simple: pintar con transparente usando m√°scara no trivial.
                # Para algo usable: dibujamos en negro con alpha 0 -> no hace nada.
                # Entonces mejor: NO incluir strokes de eraser en el export.
                # (Igual en canvas s√≠ borra porque limpiamos por stroke completo)
                continue

            color = s["color"]
            width = s["width"]
            draw.line(pts, fill=color, width=width, joint="curve")

        # nombre
        out_dir = os.path.dirname(self._orig_path) if self._orig_path else get_cache_dir()
        base_name = os.path.basename(self._orig_path) if self._orig_path else "capture.png"
        name_noext = os.path.splitext(base_name)[0]
        out_path = os.path.join(out_dir, f"{name_noext}_MARKED.png")

        try:
            base.save(out_path, "PNG")
            messagebox.showinfo("OK", f"Guardado:\n{out_path}")
        except Exception as e:
            messagebox.showerror("Error", str(e))

    # ----------------------------
    # Pan + Zoom Wheel
    # ----------------------------
    def _pan_start(self, e):
        self.canvas.scan_mark(e.x, e.y)

    def _pan_move(self, e):
        self.canvas.scan_dragto(e.x, e.y, gain=1)

    def _on_wheel(self, e):
        # Windows: delta +/-120
        if e.delta > 0:
            self.zoom_in()
        else:
            self.zoom_out()

    # ----------------------------
    # Drawing
    # ----------------------------
    def _draw_start(self, e):
        if self._orig_pil is None:
            return

        self._drawing = True
        self._current_points = []
        self._last_xy = (e.x, e.y)

        # convert canvas->img coords
        ix, iy = self._canvas_to_img(e.x, e.y)
        self._current_points.append((ix, iy))

    def _draw_move(self, e):
        if not self._drawing or self._orig_pil is None:
            return

        ix, iy = self._canvas_to_img(e.x, e.y)
        self._current_points.append((ix, iy))

        # render live (r√°pido: dibujamos s√≥lo en canvas encima)
        # Para que no se degrade, hacemos un "overlay" temporal:
        self._render(temp_points=self._current_points)

    def _draw_end(self, e):
        if not self._drawing or self._orig_pil is None:
            return
        self._drawing = False

        if len(self._current_points) >= 2:
            if self.mode == "pen":
                stroke = {
                    "mode": "pen",
                    "width": self.pen_width,
                    "color": (255, 255, 255, 255),  # blanco
                    "points": list(self._current_points),
                }
                self.strokes.append(stroke)

            elif self.mode == "highlight":
                stroke = {
                    "mode": "highlight",
                    "width": self.highlight_width,
                    "color": (241, 196, 15, 255),  # amarillo
                    "points": list(self._current_points),
                }
                self.strokes.append(stroke)

            elif self.mode == "eraser":
                # ERASER: borra ‚Äúpor stroke‚Äù lo m√°s cercano -> simplificado:
                # si hay strokes, eliminamos el √∫ltimo (muy usable como goma r√°pida)
                if self.strokes:
                    self.strokes.pop()

        self._current_points = []
        self._render()

    # ----------------------------
    # Render helpers
    # ----------------------------
    def _canvas_to_img(self, cx, cy):
        # coord canvas visible -> coord imagen (aprox)
        # Consideramos que la imagen est√° centrada.
        if self._orig_pil is None:
            return (0, 0)

        cw = max(1, self.canvas.winfo_width())
        ch = max(1, self.canvas.winfo_height())

        iw = int(self._orig_pil.width * self._scale)
        ih = int(self._orig_pil.height * self._scale)

        ox = (cw - iw) // 2
        oy = (ch - ih) // 2

        # ajustar por scroll/pan del canvas
        # canvasx/canvasy devuelven coordenadas reales considerando el scroll
        realx = self.canvas.canvasx(cx)
        realy = self.canvas.canvasy(cy)

        x = (realx - ox) / self._scale
        y = (realy - oy) / self._scale

        x = max(0, min(self._orig_pil.width - 1, x))
        y = max(0, min(self._orig_pil.height - 1, y))
        return (int(x), int(y))

    def _render(self, temp_points=None):
        self.canvas.delete("all")

        if self._orig_pil is None:
            self.canvas.create_text(
                20, 20, anchor="nw",
                fill="white",
                text="(Sin captura todav√≠a)\nCuando llegue PHOTO_DATA se mostrar√° aqu√≠.\n\nTip: click derecho para mover (pan).",
                font=("Consolas", 11)
            )
            return

        cw = max(1, self.canvas.winfo_width())
        ch = max(1, self.canvas.winfo_height())

        iw = max(1, int(self._orig_pil.width * self._scale))
        ih = max(1, int(self._orig_pil.height * self._scale))

        img_resized = self._orig_pil.resize((iw, ih), Image.LANCZOS)
        self._img_tk = ImageTk.PhotoImage(img_resized)

        ox = (cw - iw) // 2
        oy = (ch - ih) // 2

        self._img_id = self.canvas.create_image(ox, oy, anchor="nw", image=self._img_tk)

        # Dibujar strokes guardados
        self._draw_strokes_on_canvas(ox, oy)

        # Dibujar stroke temporal mientras arrastra
        if temp_points and len(temp_points) >= 2:
            self._draw_one_stroke_on_canvas(ox, oy, {
                "mode": self.mode,
                "width": self.pen_width if self.mode == "pen" else self.highlight_width,
                "color": (255, 255, 255, 255) if self.mode == "pen" else (241, 196, 15, 255),
                "points": temp_points
            })

    def _draw_strokes_on_canvas(self, ox, oy):
        for s in self.strokes:
            self._draw_one_stroke_on_canvas(ox, oy, s)

    def _rgba_to_hex(self, rgba):
        r, g, b, a = rgba
        return f"#{r:02x}{g:02x}{b:02x}"

    def _draw_one_stroke_on_canvas(self, ox, oy, s):
        pts = s["points"]
        if len(pts) < 2:
            return

        mode = s["mode"]
        width = s["width"]
        color = self._rgba_to_hex(s["color"])

        # eraser: no dibujar (porque lo tratamos como undo r√°pido)
        if mode == "eraser":
            return

        # convertir puntos img->canvas
        canvas_pts = []
        for (x, y) in pts:
            cx = ox + x * self._scale
            cy = oy + y * self._scale
            canvas_pts.extend([cx, cy])

        self.canvas.create_line(
            *canvas_pts,
            fill=color,
            width=max(1, int(width * (self._scale ** 0.15))),  # no explota con zoom
            capstyle="round",
            joinstyle="round",
            smooth=True
        )

# ======================================================================
# Networking core (socket + monitor_loop robusto)
# ======================================================================

class KClientApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Production Manager")
        self.geometry(f"{APP_W}x{APP_H}")
        self.configure(fg_color=NAVY)

        # ‚úÖ cierre limpio (si no lo at√°s, el socket puede cortarse pero el proceso queda vivo)
        try:
            self.protocol("WM_DELETE_WINDOW", self._on_close)
        except Exception:
            pass
        # =========================
        # Historial por usuario (USER_STATS)
        # =========================
        self._history_by_user: Dict[str, List[str]] = {}  # user -> lista de entradas (texto)
        self._history_max_lines = 250  # l√≠mite por usuario
        self._last_stats_fp: Dict[str, str] = {}  # user -> fingerprint
        self._last_stats_fp_ts: Dict[str, float] = {}  # user -> time.time()
        self._stats_dedup_window = 30.0  # segundos (ajustable)
        self._last_user_list_fp = None
        self._last_user_list_ts = 0.0
        self._user_list_dedup_window = 10.0  # segundos
        # =========================
        # Socket
        # =========================
        self.socket_lock = threading.Lock()
        self.send_lock = threading.Lock()  # ‚úÖ este va ac√°
        self.sock: Optional[socket.socket] = None
        self.connected = False

        # =========================
        # Auto-reconexi√≥n (cliente jefe)
        # =========================
        self._reconnect_after_id = None
        self._reconnect_in_progress = False
        self._reconnect_interval_ms = 10_000  # 10 segundos
        # =========================
        # Vigilancia (cada minuto por X minutos)
        # =========================
        self._vig_running = False
        self._vig_end_ts = 0.0
        self._vig_next_shot_ts = 0.0
        self._vig_after_id = None

        # =========================
        # Auto refresh USER_STATS (sin duplicados)
        # =========================
        self._auto_stats_thread = None
        self._auto_stats_stop = threading.Event()
        self._stats_req_last: Dict[str, float] = {}  # user -> last request time
        # =========================
        # Auto-capturas por hora (random dentro de la hora)
        # =========================
        self._hourly_shots_stop = threading.Event()
        self._hourly_shots_thread = None

        self._stats_request_cooldown = 0.20  # 200ms entre usuarios dentro de una ronda
        self._stats_req_min_interval = 20 * 60  # ‚úÖ 20 minutos por usuario
        self._stats_refresh_every = 20 * 60  # ‚úÖ 20 minutos entre rondas
        # ‚úÖ una ronda completa cada 20 minutos

        # =========================
        # Socket
        # =========================
        self.socket_lock = threading.Lock()
        self.sock: Optional[socket.socket] = None
        self.connected = False

        # =========================
        # Usuario / rol
        # =========================
        self.current_user = ""
        self.current_role = "employee"  # "boss" si corresponde
        self.activity_tracker: Optional[ActivityTracker] = None

        # =========================
        # USER_STATS block accumulator (para multiline)
        # =========================
        self._stats_block_active = False
        self._stats_block_user = None
        self._stats_block_status = None
        self._stats_block_fg_time = None
        self._stats_block_bg_time = None
        self._stats_block_lines = []
        self._stats_block_date = ""
        self._stats_flush_after_id = None

        # generaci√≥n para cancelar barridos viejos de stats all-users
        self._all_stats_req_gen = 0

        # ‚úÖ Si el servidor env√≠a las l√≠neas de stats ANTES del header USER_STATS (orden invertido), las guardamos aqu√≠
        self._pre_stats_lines = []
        # =========================
        # Ventanas
        # =========================
        self.console_win: Optional[ConsoleWindow] = None
        self.gallery_win: Optional[ScreenshotGallery] = None
        self.perf_win: Optional[PerformanceWindow] = None

        # =========================
        # UI Login + autologin
        # =========================
        self._build_login()
        self.after(350, self._try_autologin)

    # ----------------------------
    # LOGIN UI
    # ----------------------------
    def _make_stats_fingerprint(self, user: str, status: str, fg_time: str, bg_time: str,
                                top_fg: List[str], top_bg: List[str]) -> str:
        # normalizar espacios y cortar a un tama√±o razonable
        def norm_list(lst):
            out = []
            for x in (lst or []):
                x = re.sub(r"\s+", " ", x).strip()
                out.append(x)
            # si quer√©s hacerlo a√∫n m√°s agresivo: quedate con top 10
            return out[:12]

        key = {
            "user": (user or "").strip().lower(),
            "status": (status or "").strip().lower(),
            "active": (fg_time or "").strip(),
            "inactive": (bg_time or "").strip(),
            "top_fg": norm_list(top_fg),
            "top_bg": norm_list(top_bg),
        }
        return json.dumps(key, ensure_ascii=False, sort_keys=True)

    import io
    import time
    from datetime import datetime
    import pyautogui
    def _start_hourly_random_screenshots(self):
        """
        Cada hora, toma 1 captura en un segundo random dentro de esa hora.
        Solo debe correr en empleados (no jefe), y solo si hay socket conectado.
        """
        # evitar duplicar
        if self._hourly_shots_thread and self._hourly_shots_thread.is_alive():
            return

        self._hourly_shots_stop.clear()

        def worker():
            while not self._hourly_shots_stop.is_set():
                try:
                    # si no hay conexi√≥n, esperar un poco
                    if not getattr(self, "connected", False) or not getattr(self, "sock", None):
                        time.sleep(2.0)
                        continue

                    now = datetime.now()

                    # inicio de la hora actual
                    hour_start = now.replace(minute=0, second=0, microsecond=0)

                    # elegir un segundo random dentro de la hora [0..3599]
                    offset_sec = random.randint(0, 3599)
                    target = hour_start + timedelta(seconds=offset_sec)

                    # si ya pas√≥, programar para la pr√≥xima hora
                    if target <= now:
                        next_hour = hour_start + timedelta(hours=1)
                        offset_sec = random.randint(0, 3599)
                        target = next_hour + timedelta(seconds=offset_sec)

                    # dormir hasta el target (en pasos para poder cortar r√°pido)
                    while not self._hourly_shots_stop.is_set():
                        remaining = (target - datetime.now()).total_seconds()
                        if remaining <= 0:
                            break
                        time.sleep(min(1.0, remaining))

                    if self._hourly_shots_stop.is_set():
                        break

                    # disparar captura
                    try:
                        # tag AUTO (o lo que quieras)
                        self._take_and_send_screenshot(tag="AUTO")
                    except Exception:
                        pass

                    # y volver a calcular otra vez (siguiente hora)
                except Exception:
                    time.sleep(2.0)

        self._hourly_shots_thread = threading.Thread(target=worker, daemon=True)
        self._hourly_shots_thread.start()

    def _stop_hourly_random_screenshots(self):
        try:
            self._hourly_shots_stop.set()
        except Exception:
            pass

    def _format_mmss(self, sec: int) -> str:
        sec = max(0, int(sec))
        m = sec // 60
        s = sec % 60
        return f"{m:02d}:{s:02d}"

    def _start_vigilance(self):
        # valida seleccionado
        user = (self.selected_user_var.get() or "").strip()
        if not user or user.lower() in ("seleccionar empleado", "select user", "select"):
            messagebox.showinfo("Info", "Primero seleccion√° un empleado para vigilar.")
            return

        # valida input
        try:
            mins = int((self.vig_entry.get() or "").strip())
        except:
            mins = 0

        if mins <= 0:
            messagebox.showinfo("Info", "Ingres√° un n√∫mero de minutos v√°lido (>= 1).")
            return

        if not getattr(self, "sock", None) or not getattr(self, "connected", False):
            messagebox.showerror("Error", "No conectado al servidor.")
            return

        # arrancar
        now = time.time()
        self._vig_running = True
        self._vig_end_ts = now + mins * 60
        self._vig_next_shot_ts = now  # ‚úÖ primera captura inmediata

        # UI: bot√≥n rojo + texto
        if hasattr(self, "vig_btn") and self.vig_btn:
            self.vig_btn.configure(text="Detener", fg_color=DANGER, hover_color="#c0392b")
        if hasattr(self, "vig_status_lbl") and self.vig_status_lbl:
            self.vig_status_lbl.configure(text="Estado: ACTIVO", text_color=WARN)

        # lanzar loop
        self._vigilance_tick()

    def _stop_vigilance(self):
        self._vig_running = False
        self._vig_end_ts = 0.0
        self._vig_next_shot_ts = 0.0

        # cancelar after si existe
        try:
            if self._vig_after_id is not None:
                self.after_cancel(self._vig_after_id)
        except:
            pass
        self._vig_after_id = None

        # UI: volver a iniciar
        if hasattr(self, "vig_btn") and self.vig_btn:
            self.vig_btn.configure(text="Iniciar", fg_color=OK, hover_color="#27ae60")
        if hasattr(self, "vig_status_lbl") and self.vig_status_lbl:
            self.vig_status_lbl.configure(text="Estado: detenido", text_color=MUTED)
        if hasattr(self, "vig_count_lbl") and self.vig_count_lbl:
            self.vig_count_lbl.configure(text="00:00")

    def _toggle_vigilance(self):
        if self._vig_running:
            self._stop_vigilance()
        else:
            self._start_vigilance()

    def _vigilance_tick(self):
        if not self._vig_running:
            return

        now = time.time()
        remaining = int(self._vig_end_ts - now)

        # termin√≥
        if remaining <= 0:
            self._stop_vigilance()
            return

        # countdown UI
        if hasattr(self, "vig_count_lbl") and self.vig_count_lbl:
            self.vig_count_lbl.configure(text=self._format_mmss(remaining))

        # ¬øtoca pedir captura?
        if now >= self._vig_next_shot_ts:
            try:
                user = (self.selected_user_var.get() or "").strip()
                if user and user.lower() not in ("seleccionar empleado", "select user", "select"):
                    tag = "VIG"
                    lock = getattr(self, "send_lock", None) or getattr(self, "socket_lock", None)
                    if lock:
                        with lock:
                            self.sock.sendall(f"SEND_SCREENSHOT|{user}|{tag}\n".encode("utf-8"))
                    else:
                        self.sock.sendall(f"SEND_SCREENSHOT|{user}|{tag}\n".encode("utf-8"))
            except Exception as e:
                # si falla el pedido, no matamos el loop
                print("vigilance screenshot error:", e)

            # pr√≥xima captura en 60s exactos
            self._vig_next_shot_ts = now + 60.0

        # tick cada 1s
        self._vig_after_id = self.after(1000, self._vigilance_tick)

    def _take_and_send_screenshot(self, tag: str = "MANUAL", target_user: str = None):
        try:
            if not self.sock or not self.connected:
                return

            tag = (tag or "MANUAL").strip().replace(" ", "_")
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")

            # ‚úÖ si el server manda el target, lo usamos
            # si no, usamos el usuario actual (empleado)
            user_for_filename = (target_user or self.current_user or "UNKNOWN").strip()

            fname = f"{user_for_filename}_{tag}_{ts}.png"

            img = pyautogui.screenshot()

            buf = io.BytesIO()
            img.save(buf, format="PNG")
            data = buf.getvalue()
            size = len(data)

            header = f"SCREENSHOT_DATA|{fname}|{size}\n".encode("utf-8")

            with self.send_lock:
                self.sock.sendall(header + data)

        except Exception as e:
            print(f"[TAKE_SCREENSHOT] error: {e}")

    def _should_ignore_duplicate_user_list(self, users: List[str]) -> bool:
        now = time.time()
        fp = ",".join([u.strip().lower() for u in (users or []) if u and u.strip()])

        if self._last_user_list_fp == fp and (now - self._last_user_list_ts) < self._user_list_dedup_window:
            return True

        self._last_user_list_fp = fp
        self._last_user_list_ts = now
        return False

    def _should_ignore_duplicate_stats(self, user: str, date_str: str, fingerprint: str) -> bool:
        user = (user or "").strip()
        if not user:
            return False

        now = time.time()
        fp_key = f"{user}|{date_str}"
        last_fp = self._last_stats_fp.get(fp_key)
        last_ts = self._last_stats_fp_ts.get(user, 0.0)

        if last_fp == fingerprint and (now - last_ts) < self._stats_dedup_window:
            return True

        self._last_stats_fp[fp_key] = fingerprint
        self._last_stats_fp_ts[fp_key] = now
        return False

    def _append_user_history(self, user: str, entry: str):
        user = (user or "").strip()
        if not user:
            return
        if user not in self._history_by_user:
            self._history_by_user[user] = []

        # ‚úÖ De-dup simple: si es igual a la √∫ltima, no lo vuelvas a guardar
        if self._history_by_user[user]:
            last = self._history_by_user[user][-1]
            if last.strip() == entry.strip():
                return

        self._history_by_user[user].append(entry)

        # recortar para no crecer infinito
        if len(self._history_by_user[user]) > self._history_max_lines:
            self._history_by_user[user] = self._history_by_user[user][-self._history_max_lines:]

    def _render_history_for_user(self, user: str, loading: bool = False):
        if not hasattr(self, "history_box") or not self.history_box:
            return

        user = (user or "").strip()
        try:
            self.history_box.delete("1.0", "end")

            if loading:
                self.history_box.insert("end", f"Cargando historial de {user}...\n")
                self.history_box.see("end")
                return

            lines = self._history_by_user.get(user, [])
            if not lines:
                self.history_box.insert("end", f"‚Äî Sin historial para {user} ‚Äî\n")
            else:
                self.history_box.insert("end", "\n\n".join(lines) + "\n")
            self.history_box.see("1.0")

        except:
            pass

    def _is_header_line(self, line: str) -> bool:
        if not line:
            return False
        prefixes = (
            "USER_LIST|",
            "USER_STATS|",
            "SCREENSHOT_LIST|",
            "PHOTO_DATA|",
            "CONSOLE_OUTPUT|",
            "SHOW_POPUP|",
            "TAKE_SCREENSHOT|",
            "SYNC_CHECK|",
            "AI_LOG_DATA|",
            "AI_CHAT_RESP|",
            "HIST_DATES|",
            "HIST_DATA|",
            "DISTRACTION_CFG|",
            "TASKS_SYNC|",
            "TASK_EVT|",
            "REWARDS_SYNC|",
            "REWARD_EVT|",
            "PONG",
        )
        return line.startswith(prefixes)

    def _request_user_stats_throttled(self, user: str):
        user = (user or "").strip()
        if not user:
            return
        if not getattr(self, "sock", None) or not getattr(self, "connected", False):
            return

        now = time.time()
        last = self._stats_req_last.get(user, 0.0)
        if (now - last) < self._stats_req_min_interval:
            return

        self._stats_req_last[user] = now
        self._request_user_stats(user)

    def _start_auto_stats_refresh(self, users: List[str]):
        users = [u.strip() for u in (users or []) if u and u.strip()]
        if not users:
            return

        # stop anterior
        try:
            self._auto_stats_stop.set()
        except Exception:
            pass

        self._auto_stats_stop = threading.Event()
        stop_evt = self._auto_stats_stop

        def do_round():
            for u in users:
                if stop_evt.is_set():
                    return
                self._request_user_stats_throttled(u)
                time.sleep(self._stats_request_cooldown)

        def worker():
            # ‚úÖ 1 ronda inmediata al entrar
            do_round()

            # ‚úÖ luego esperar 20 min y reci√©n ah√≠ repetir
            while not stop_evt.is_set():
                sleep_total = self._stats_refresh_every
                step = 0.5
                while sleep_total > 0 and not stop_evt.is_set():
                    time.sleep(min(step, sleep_total))
                    sleep_total -= step

                if stop_evt.is_set():
                    return

                do_round()

        self._auto_stats_thread = threading.Thread(target=worker, daemon=True)
        self._auto_stats_thread.start()

    def _flush_user_stats_block(self):
        try:
            self._stats_flush_after_id = None
        except Exception:
            pass
        if not self._stats_block_active:
            return
        self._stats_block_active = False

        user = self._stats_block_user
        status = self._stats_block_status
        fg_time = self._stats_block_fg_time
        bg_time = self._stats_block_bg_time
        lines = list(self._stats_block_lines)
        date_str = getattr(self, "_stats_block_date", "")
        self._stats_block_lines = []

        # Des-escapar \\n literales ‚Üí saltos reales
        unescaped = []
        for ln in lines:
            if "\\n" in ln:
                for sub in ln.replace("\\n", "\n").split("\n"):
                    unescaped.append(sub)
            else:
                unescaped.append(ln)
        lines = unescaped

        # Construir historial raw
        history_raw = "\n".join(lines)

        # Cachear en _latest_stats
        if not hasattr(self, "_latest_stats") or self._latest_stats is None:
            self._latest_stats = {}
        self._latest_stats.setdefault(user, {})
        self._latest_stats[user]["fg_time"] = fg_time
        self._latest_stats[user]["bg_time"] = bg_time
        self._latest_stats[user]["status"] = status
        self._latest_stats[user]["raw"] = history_raw

        # Cachear historial por usuario
        self._append_user_history(user, history_raw)

        # Actualizar PerformanceView si es el usuario activo
        def ui():
            # ‚úÖ COMPROBACI√ìN CR√çTICA: winfo_exists()
            try:
                if hasattr(self, "perf_view") and self.perf_view and self.perf_view.winfo_exists():
                    if getattr(self.perf_view, "target_user", None) == user:
                        self.perf_view.update_data(
                            active_time_str=fg_time,
                            inactive_time_str=bg_time,
                            history_raw=history_raw,
                        )

                # Repite para cada widget que actualices
                if hasattr(self, "employees_panel") and self.employees_panel and self.employees_panel.winfo_exists():
                    color = "#2ecc71" if status == "ONLINE" else "#e74c3c"
                    self.employees_panel.set_user_status(user, status, color=color)
            except Exception as e:
                print(f"Widget ya no existe, ignorando actualizaci√≥n: {e}")

        try:
            self.after(0, ui)
        except Exception:
            ui()


    def _ui_set_loading_user(self, user):
        if hasattr(self, "perf_view") and self.perf_view and self.perf_view.winfo_exists():
            try:
                self.perf_view.set_loading(user)
            except Exception:
                pass  # si no existe set_loading, no pasa nada

    def _ui_set_history_text(self, text):
        def ui():
            if not hasattr(self, "history_box") or not self.history_box or not self.history_box.winfo_exists():
                return
            self.history_box.configure(state="normal")
            self.history_box.delete("1.0", "end")
            self.history_box.insert("1.0", text)
            self.history_box.see("1.0")  # <-- se queda ARRIBA
            self.history_box.configure(state="disabled")

        self.after(0, ui)

    def _touch_stats_block(self):
        self._stats_block_last_ts = time.time()
        if getattr(self, "_stats_block_watchdog_running", False):
            return
        self._stats_block_watchdog_running = True

        def watchdog():
            if getattr(self, "_stats_block_active", False):
                last = getattr(self, "_stats_block_last_ts", 0)
                if time.time() - last > 0.6:
                    self._flush_user_stats_block()
            self.after(200, watchdog)

        self.after(200, watchdog)

    def _build_login(self):
        self.login_root = ctk.CTkFrame(self, fg_color="transparent")
        self.login_root.pack(fill="both", expand=True)

        bg = GradientCanvas(self.login_root, "#0b1b2b", "#06101b", animate=True)
        bg.pack(fill="both", expand=True)

        box = ctk.CTkFrame(self.login_root, fg_color=CARD, corner_radius=18)
        box.place(relx=0.5, rely=0.5, anchor="center")

        ctk.CTkLabel(box, text="CSD Viajes ‚Ä¢ K-Client", font=("Roboto", 18, "bold")).pack(padx=22, pady=(18, 6))
        ctk.CTkLabel(box, text="Ingres√° tus credenciales", text_color=MUTED).pack(padx=22, pady=(0, 14))

        self.user_entry = ctk.CTkEntry(box, width=280, placeholder_text="Usuario", fg_color=CARD2)
        self.user_entry.pack(padx=22, pady=8)

        self.pass_entry = ctk.CTkEntry(box, width=280, placeholder_text="Contrase√±a", show="‚Ä¢", fg_color=CARD2)
        self.pass_entry.pack(padx=22, pady=8)

        row = ctk.CTkFrame(box, fg_color="transparent")
        row.pack(fill="x", padx=22, pady=(10, 18))

        self.server_entry = ctk.CTkEntry(row, placeholder_text="IP servidor", fg_color=CARD2)
        self.server_entry.insert(0, DEFAULT_HOST)
        self.server_entry.pack(side="left", expand=True, fill="x", padx=(0, 8))

        self.port_entry = ctk.CTkEntry(row, placeholder_text="Puerto", width=90, fg_color=CARD2)
        self.port_entry.insert(0, str(DEFAULT_PORT))
        self.port_entry.pack(side="left")

        self.btn_login = ctk.CTkButton(box, text="Conectar", fg_color=TURQ, text_color="#001013",
                                       hover_color="#12b5aa", command=self._do_login)
        self.btn_login.pack(padx=22, pady=(0, 18), fill="x")

        # cargar cred si existen
        self._load_creds()

    def _try_autologin(self):
        try:
            p = cred_file_path()
            if not os.path.exists(p):
                return
            with open(p, "r", encoding="utf-8") as f:
                lines = [x.strip() for x in f.read().splitlines() if x.strip()]
            if len(lines) < 2:
                return
            saved_user, saved_pass = lines[0], lines[1]
            if not saved_user or not saved_pass:
                return

            # Rellenar UI (opcional)
            self.user_entry.delete(0, "end")
            self.user_entry.insert(0, saved_user)
            self.pass_entry.delete(0, "end")
            self.pass_entry.insert(0, saved_pass)

            # ‚úÖ Autoconectar
            self._do_login()
        except:
            pass

    def _load_creds(self):
        p = cred_file_path()
        if os.path.exists(p):
            try:
                with open(p, "r", encoding="utf-8") as f:
                    lines = [x.strip() for x in f.read().splitlines() if x.strip()]
                if len(lines) >= 2:
                    self.user_entry.delete(0, "end")
                    self.user_entry.insert(0, lines[0])
                    self.pass_entry.delete(0, "end")
                    self.pass_entry.insert(0, lines[1])
            except:
                pass

    def _save_creds(self, u, pw):
        try:
            with open(cred_file_path(), "w", encoding="utf-8") as f:
                f.write(u.strip() + "\n" + pw.strip() + "\n")
        except:
            pass

    def _do_login(self):
        u = self.user_entry.get().strip()
        pw = self.pass_entry.get().strip()
        host = (self.server_entry.get().strip() or DEFAULT_HOST)
        port_raw = (self.port_entry.get().strip() or str(DEFAULT_PORT))

        if not u or not pw:
            messagebox.showerror("Error", "Usuario y contrase√±a requeridos.")
            return

        try:
            port = int(port_raw)
        except ValueError:
            messagebox.showerror("Error", "Puerto inv√°lido.")
            return

        self.btn_login.configure(state="disabled", text="Conectando...")

        def task():
            ok = self._connect(host, port)
            if not ok:
                self.after(0, lambda: self.btn_login.configure(state="normal", text="Conectar"))
                return

            # ‚úÖ Protocolo real: "user,pass" y respuesta "OK,..."
            try:
                with self.socket_lock:
                    self.sock.sendall(f"{u},{pw}".encode("utf-8"))
                resp_raw = self.sock.recv(1024).decode("utf-8", errors="ignore").strip()
            except Exception as e:
                self.after(0, lambda: messagebox.showerror("Error", f"No se pudo loguear: {e}"))
                self.after(0, lambda: self.btn_login.configure(state="normal", text="Conectar"))
                return

            if not resp_raw.startswith("OK"):
                try:
                    with self.socket_lock:
                        self.sock.close()
                except:
                    pass
                self.sock = None
                self.connected = False
                self.after(0, lambda: messagebox.showerror("Error", "Acceso Denegado"))
                self.after(0, lambda: self.btn_login.configure(state="normal", text="Conectar"))
                return

            # ‚úÖ Rol (si viene como "OK,<rol>....")
            parts = resp_raw.split(",")
            role = "empleado"
            if len(parts) > 1:
                role = parts[1].split("CONSOLE")[0].split("SHOW")[0].strip() or "empleado"
            self.current_role = "boss" if role.lower() in ("jefe", "boss", "admin") else "employee"
            # ... despu√©s de calcular role/current_role y antes de _enter_main_ui
            threading.Thread(target=self._listen_loop, daemon=True).start()

            self.current_user = u
            self._save_creds(u, pw)

            self.after(0, self._enter_main_ui)

        threading.Thread(target=task, daemon=True).start()

    def _connect(self, host, port) -> bool:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(6)
            s.connect((host, port))
            s.settimeout(None)
            self.sock = s
            self.connected = True
            # ‚ùå NO arrancar listen_loop todav√≠a
            return True
        except Exception as e:
            self.after(0, lambda: messagebox.showerror("Error", f"No se pudo conectar: {e}"))
            self.connected = False
            self.sock = None
            return False

    # ----------------------------
    # RECONEXI√ìN (manual + autom√°tica)
    # ----------------------------
    def _get_saved_creds(self) -> Tuple[str, str]:
        """Lee usuario/contrase√±a guardados. Devuelve (user, pass) o ("", "")."""
        try:
            p = cred_file_path()
            if not os.path.exists(p):
                return "", ""
            with open(p, "r", encoding="utf-8") as f:
                lines = [x.strip() for x in f.read().splitlines() if x.strip()]
            if len(lines) >= 2:
                return lines[0], lines[1]
        except Exception:
            pass
        return "", ""

    def _set_connection_state(self, is_connected: bool):
        """Actualiza flags + UI de conexi√≥n de forma segura."""
        self.connected = bool(is_connected)

        def _ui():
            try:
                if hasattr(self, "lbl_status") and self.lbl_status and self.lbl_status.winfo_exists():
                    self.lbl_status.configure(
                        text=("Estado: Conectado" if self.connected else "Estado: Desconectado"),
                        text_color=(OK if self.connected else DANGER)
                    )
            except Exception:
                pass
            try:
                if hasattr(self, "chrome") and self.chrome and self.chrome.winfo_exists():
                    self.chrome.set_wifi("Wi-Fi: Conectado" if self.connected else "Wi-Fi: Desconectado")
            except Exception:
                pass
            try:
                # bot√≥n de reconectar si existe en Dashboard
                btn = getattr(self, "btn_reconnect", None)
                if btn is not None and btn.winfo_exists():
                    btn.configure(state=("disabled" if self.connected else "normal"))
            except Exception:
                pass

        try:
            self.after(0, _ui)
        except Exception:
            _ui()

    def _manual_reconnect(self):
        """Bot√≥n: intenta reconectar ahora."""
        if self.connected:
            return
        # disparar intento inmediato
        self._reconnect_once(user_initiated=True)

    def _reconnect_once(self, user_initiated: bool = False):
        """Hace UN intento de reconexi√≥n (en thread) usando creds guardadas."""
        if self._reconnect_in_progress:
            return
        self._reconnect_in_progress = True

        def worker():
            try:
                # limpiar socket viejo
                try:
                    if getattr(self, "sock", None):
                        with self.socket_lock:
                            try:
                                self.sock.close()
                            except Exception:
                                pass
                finally:
                    self.sock = None
                    self.connected = False

                u, pw = self._get_saved_creds()
                if not u or not pw:
                    if user_initiated:
                        self.after(0, lambda: messagebox.showinfo("Reconectar", "No hay credenciales guardadas. Volv√© a iniciar sesi√≥n."))
                    return

                ok = self._connect(DEFAULT_HOST, DEFAULT_PORT)
                if not ok:
                    return

                # auth real: "user,pass" y respuesta "OK,..."
                try:
                    with self.socket_lock:
                        self.sock.sendall(f"{u},{pw}".encode("utf-8"))
                    resp_raw = self.sock.recv(1024).decode("utf-8", errors="ignore").strip()
                except Exception:
                    # fall√≥ auth
                    try:
                        with self.socket_lock:
                            self.sock.close()
                    except Exception:
                        pass
                    self.sock = None
                    self.connected = False
                    return

                if not resp_raw.startswith("OK"):
                    try:
                        with self.socket_lock:
                            self.sock.close()
                    except Exception:
                        pass
                    self.sock = None
                    self.connected = False
                    if user_initiated:
                        self.after(0, lambda: messagebox.showerror("Reconectar", "Acceso denegado al reconectar."))
                    return

                parts = resp_raw.split(",")
                role = "empleado"
                if len(parts) > 1:
                    role = parts[1].split("CONSOLE")[0].split("SHOW")[0].strip() or "empleado"
                self.current_role = "boss" if role.lower() in ("jefe", "boss", "admin") else "employee"
                self.current_user = u

                # arrancar listener nuevo
                threading.Thread(target=self._listen_loop, daemon=True).start()

                # UI + refrescos
                self._set_connection_state(True)
                try:
                    self.after(0, lambda: self._request_user_list())
                except Exception:
                    pass
                if user_initiated:
                    self.after(0, lambda: messagebox.showinfo("Reconectar", "Conectado nuevamente."))
            finally:
                self._reconnect_in_progress = False

        threading.Thread(target=worker, daemon=True).start()

    def _start_reconnect_watchdog(self):
        """Cada 10s intenta reconectar si est√° desconectado."""
        self._stop_reconnect_watchdog()

        def tick():
            # reprogramar primero para que nunca se corte
            try:
                self._reconnect_after_id = self.after(self._reconnect_interval_ms, tick)
            except Exception:
                self._reconnect_after_id = None
                return

            if not getattr(self, "connected", False):
                self._set_connection_state(False)
                self._reconnect_once(user_initiated=False)

        self._reconnect_after_id = self.after(self._reconnect_interval_ms, tick)

    def _stop_reconnect_watchdog(self):
        try:
            if getattr(self, "_reconnect_after_id", None):
                self.after_cancel(self._reconnect_after_id)
        except Exception:
            pass
        self._reconnect_after_id = None

    # ----------------------------
    # MAIN UI
    # ----------------------------
    def _enter_main_ui(self):
        self.login_root.destroy()

        # Chrome (arriba)
        self.chrome = WindowChrome(
            self,
            title_left=f"{self.current_user}",
            wifi_text="Wi-Fi: Conectado" if self.connected else "Wi-Fi: Desconectado",
            on_close=self._on_close
        )
        self.chrome.pack(fill="x", padx=0, pady=0)

        # Contenedor principal (IMPORTANTE: no transparente)
        root = ctk.CTkFrame(self, fg_color=NAVY)
        root.pack(fill="both", expand=True, padx=0, pady=0)
        root.pack_propagate(False)

        # Sidebar
        self.sidebar = ctk.CTkFrame(root, fg_color="#071423", width=240)
        self.sidebar.pack(side="left", fill="y", padx=0, pady=0)
        self.sidebar.pack_propagate(False)

        # Content
        self.content = ctk.CTkFrame(root, fg_color=NAVY)
        self.content.pack(side="left", fill="both", expand=True, padx=0, pady=0)

        # ----- Header sidebar -----
        ctk.CTkLabel(self.sidebar, text="CSD Viajes", font=("Roboto", 16, "bold")).pack(
            padx=14, pady=(14, 2), anchor="w"
        )

        status_text = "Estado: Conectado" if self.connected else "Estado: Desconectado"
        status_color = OK if self.connected else DANGER
        self.lbl_status = ctk.CTkLabel(self.sidebar, text=status_text, text_color=status_color,
                                       font=("Roboto", 12, "bold"))
        self.lbl_status.pack(padx=14, pady=(0, 12), anchor="w")

        ctk.CTkFrame(self.sidebar, height=2, fg_color="#0e2238").pack(fill="x", padx=12, pady=(0, 10))

        ctk.CTkLabel(self.sidebar, text="Bienvenido, Jefe", text_color=WHITE, font=("Roboto", 13, "bold")).pack(
            padx=14, pady=(0, 10), anchor="w"
        )

        # ----- Men√∫ -----
        IconNavButton(self.sidebar, "Dashboard", "üè†", self._view_dashboard).pack(fill="x", padx=10, pady=4)
        IconNavButton(self.sidebar, "Rendimiento", "üìä", self._open_performance).pack(fill="x", padx=10, pady=4)
        IconNavButton(self.sidebar, "Galer√≠a", "üì∑", self._open_gallery).pack(fill="x", padx=10, pady=4)
        IconNavButton(self.sidebar, "Consola", "üñ•Ô∏è", self._open_console).pack(fill="x", padx=10, pady=4)
        IconNavButton(self.sidebar, "Tareas", "ü§ñ", self._view_boss).pack(fill="x", padx=10, pady=4)

        # ‚úÖ Nueva TAB debajo de Boss
        IconNavButton(self.sidebar, "Configuraci√≥n", "‚öôÔ∏è", self._view_settings).pack(fill="x", padx=10, pady=4)

        # Spacer para empujar lo de abajo
        ctk.CTkFrame(self.sidebar, fg_color="transparent").pack(fill="both", expand=True)

        # ----- Acciones r√°pidas (abajo) -----
        quick = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        quick.pack(fill="x", padx=12, pady=(0, 14))

        ctk.CTkLabel(quick, text="Acciones r√°pidas", text_color=MUTED, font=("Roboto", 11, "bold")).pack(
            anchor="w", padx=2, pady=(0, 8)
        )

        ctk.CTkButton(quick, text="üìä Rendimiento", fg_color=CARD2, hover_color="#22324a",
                      command=self._open_performance).pack(fill="x", pady=4)
        ctk.CTkButton(quick, text="üì∑ Galer√≠a", fg_color=CARD2, hover_color="#22324a",
                      command=self._open_gallery).pack(fill="x", pady=4)
        ctk.CTkButton(quick, text="üñ•Ô∏è Consola", fg_color=CARD2, hover_color="#22324a",
                      command=self._open_console).pack(fill="x", pady=4)

        # Holder principal
        self.main_holder = ctk.CTkFrame(self.content, fg_color="transparent")
        self.main_holder.pack(fill="both", expand=True, padx=0, pady=0)

        self._view_dashboard()

        # ‚úÖ Auto-reconectar si se corta la conexi√≥n
        try:
            self._start_reconnect_watchdog()
        except Exception:
            pass

        # Activity tracker
        self.activity_tracker = ActivityTracker(send_func=self._send_json, username=self.current_user,
                                                interval_send=10.0)

        # Monitor loop
        threading.Thread(target=self._monitor_loop, daemon=True).start()
        # ‚úÖ Auto-captura 1 vez por hora (random) para TODOS (boss o employee)
        self._start_hourly_random_screenshots()

        self.btn_login = None

    def _clear_main_holder(self):
        for w in self.main_holder.winfo_children():
            w.destroy()

    def _view_settings(self):
        """
        Pesta√±a Configuraci√≥n (funcional):
        - Card superior: datos del usuario seleccionado (online/offline + tiempos)
        - Acciones: setrole, add user, reset capturas, reset historial, reset semanal ya
        """
        self._clear_main_holder()

        # --- helpers internos ---
        def _send_remote(cmd: str) -> bool:
            cmd = (cmd or "").strip()
            if not cmd:
                return False
            if not getattr(self, "sock", None) or not getattr(self, "connected", False):
                messagebox.showerror("Error", "No conectado al servidor.")
                return False
            try:
                with self.socket_lock:
                    # algunos handlers tuyos esperan \n; CMD_REMOTE no lo necesita, pero no molesta.
                    self.sock.sendall((f"CMD_REMOTE|{cmd}\n").encode("utf-8"))
                return True
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo enviar: {e}")
                return False

        def _safe_int(x, default=0):
            try:
                return int(float(str(x).strip()))
            except Exception:
                return default

        def _fmt_hms(sec: int) -> str:
            sec = max(0, int(sec))
            h = sec // 3600
            m = (sec % 3600) // 60
            s = sec % 60
            if h > 0:
                return f"{h}h {m:02d}m"
            return f"{m}m {s:02d}s"

        def _get_stats_for(user: str):
            latest = getattr(self, "_latest_stats", {}) or {}
            return latest.get(user, {}) or {}

        def _refresh_user_card():
            try:
                user = (self.settings_user_var.get() or "").strip()
                if not user:
                    return

                # conexi√≥n
                online = bool(getattr(self, "connected", False))
                online_txt = "S√≠" if online else "No"
                online_col = OK if online else DANGER

                # stats (si ya llegaron)
                info = _get_stats_for(user)
                fg = _safe_int(info.get("fg_time", 0))
                bg = _safe_int(info.get("bg_time", 0))
                status_raw = (info.get("status") or "").strip()

                self._settings_lbl_name.configure(text=user)
                self._settings_lbl_role.configure(
                    text=f"Rol actual: {'Jefe' if getattr(self, 'current_role', '') == 'boss' else 'Empleado'}"
                )
                self._settings_lbl_online.configure(text=f"Online: {online_txt}", text_color=online_col)

                # Si el server manda un status por user en USER_STATS, lo mostramos; sino, mostramos conexi√≥n.
                if status_raw:
                    self._settings_lbl_state.configure(text=f"Estado: {status_raw}", text_color=WARN)
                else:
                    self._settings_lbl_state.configure(text="Estado: ‚Äî", text_color=MUTED)

                self._settings_lbl_times.configure(
                    text=f"Tiempo activo (FG): {_fmt_hms(fg)}   ‚Ä¢   Inactivo (BG): {_fmt_hms(bg)}"
                )
            except Exception:
                pass

        def _schedule_refresh():
            _refresh_user_card()
            # refresco suave (si cambia el connected o llegan stats nuevos)
            self._settings_after_id = self.after(1200, _schedule_refresh)

        def _cancel_refresh():
            try:
                if getattr(self, "_settings_after_id", None):
                    self.after_cancel(self._settings_after_id)
            except Exception:
                pass
            self._settings_after_id = None

        def _start_countdown():
            # pr√≥ximo s√°bado 00:00
            try:
                now = datetime.now()
                # weekday(): lunes=0 ... domingo=6
                days_ahead = (5 - now.weekday()) % 7  # s√°bado = 5
                target = (now + timedelta(days=days_ahead)).replace(hour=0, minute=0, second=0, microsecond=0)
                if target <= now:
                    target = target + timedelta(days=7)

                diff = int((target - now).total_seconds())
                if diff < 0:
                    diff = 0
                dd = diff // 86400
                hh = (diff % 86400) // 3600
                mm = (diff % 3600) // 60
                ss = diff % 60
                if dd > 0:
                    txt = f"{dd}d {hh:02d}:{mm:02d}:{ss:02d}"
                else:
                    txt = f"{hh:02d}:{mm:02d}:{ss:02d}"

                if hasattr(self, "lbl_countdown") and self.lbl_countdown and self.lbl_countdown.winfo_exists():
                    self.lbl_countdown.configure(text=txt)

                self._settings_count_after = self.after(1000, _start_countdown)
            except Exception:
                # si fall√≥, reintentar luego
                try:
                    self._settings_count_after = self.after(2000, _start_countdown)
                except Exception:
                    pass

        def _cancel_countdown():
            try:
                if getattr(self, "_settings_count_after", None):
                    self.after_cancel(self._settings_count_after)
            except Exception:
                pass
            self._settings_count_after = None

        # ------------------------------------------------------------------
        # UI
        # ------------------------------------------------------------------
        card = ctk.CTkFrame(self.main_holder, fg_color=CARD, corner_radius=18)
        card.pack(fill="both", expand=True, padx=16, pady=16)

        ctk.CTkLabel(card, text="‚öôÔ∏è Configuraci√≥n", font=("Roboto", 18, "bold")).pack(
            anchor="w", padx=16, pady=(16, 10)
        )

        # --- Rect√°ngulo: Datos de usuario ---
        top = ctk.CTkFrame(card, fg_color=CARD2, corner_radius=16)
        top.pack(fill="x", padx=14, pady=(0, 12))

        left = ctk.CTkFrame(top, fg_color="transparent")
        left.pack(side="left", padx=12, pady=12)

        avatar = ctk.CTkLabel(left, text="üë§", width=56, height=56, corner_radius=28,
                              fg_color=CARD, text_color=WHITE, font=("Roboto", 22))
        avatar.pack(side="left", padx=(0, 12))

        info = ctk.CTkFrame(left, fg_color="transparent")
        info.pack(side="left")

        # selector de usuario para el card
        users = list(getattr(self, "_cached_users", []) or [])

        if not users:
            users = [getattr(self, "current_user", "")] if getattr(self, "current_user", "") else []
        users = [u for u in users if u]

        self.settings_user_var = ctk.StringVar(value=(
            getattr(self, "current_user", "") if getattr(self, "current_user", "") in users else (
                users[0] if users else "")))

        # Nombre (label grande) + optionmenu al lado
        name_row = ctk.CTkFrame(info, fg_color="transparent")
        name_row.pack(anchor="w")
        self._settings_lbl_name = ctk.CTkLabel(name_row, text=self.settings_user_var.get() or "‚Äî",
                                               font=("Roboto", 16, "bold"), text_color=WHITE)
        self._settings_lbl_name.pack(side="left")

        self._settings_lbl_role = ctk.CTkLabel(info, text="Rol actual: ‚Äî", text_color="#b8c4d0")
        self._settings_lbl_role.pack(anchor="w")

        self._settings_lbl_online = ctk.CTkLabel(info, text="Online: ‚Äî", text_color="#b8c4d0")
        self._settings_lbl_online.pack(anchor="w")

        self._settings_lbl_state = ctk.CTkLabel(info, text="Estado: ‚Äî", text_color="#b8c4d0")
        self._settings_lbl_state.pack(anchor="w")

        self._settings_lbl_times = ctk.CTkLabel(info, text="Tiempo activo (FG): ‚Äî   ‚Ä¢   Inactivo (BG): ‚Äî",
                                                text_color="#b8c4d0")
        self._settings_lbl_times.pack(anchor="w")

        # bot√≥n manual refresh
        ctk.CTkButton(
            top,
            text="Actualizar datos ‚ü≥",
            width=160,
            fg_color=TURQ,
            text_color="#001013",
            hover_color="#12b5aa",
            command=lambda: (self._request_user_stats((self.settings_user_var.get() or '').strip()),
                             _refresh_user_card())
        ).pack(side="right", padx=12, pady=12)

        # --- Acciones ---
        actions = ctk.CTkFrame(card, fg_color="transparent")
        actions.pack(fill="both", expand=True, padx=14, pady=(0, 14))

        ctk.CTkLabel(actions, text="Acciones", font=("Roboto", 14, "bold"), text_color=WHITE).pack(anchor="w",
                                                                                                   pady=(0, 8))

        # 1) Cambiar rol
        r1 = ctk.CTkFrame(actions, fg_color=CARD2, corner_radius=14)
        r1.pack(fill="x", pady=8)
        ctk.CTkLabel(r1, text="Cambiar rol a usuario", text_color=WHITE).pack(side="left", padx=12, pady=12)

        # lista de usuarios (cache)
        self.setrole_user = ctk.StringVar(value="Seleccionar")
        values_users = ["Seleccionar"] + (users if users else [])
        self._settings_setrole_menu_user = ctk.CTkOptionMenu(
            r1, values=values_users, variable=self.setrole_user,
            fg_color=CARD, button_color="#22324a", button_hover_color="#2a3d5e"
        )
        self._settings_setrole_menu_user.pack(side="left", padx=8)

        self.setrole_role = ctk.StringVar(value="Empleado")
        self._settings_setrole_menu_role = ctk.CTkOptionMenu(
            r1, values=["Jefe", "Empleado"], variable=self.setrole_role,
            fg_color=CARD, button_color="#22324a", button_hover_color="#2a3d5e"
        )
        self._settings_setrole_menu_role.pack(side="left", padx=8)

        def _apply_setrole():
            u = (self.setrole_user.get() or "").strip()
            if not u or u.lower() == "seleccionar":
                messagebox.showinfo("Info", "Seleccion√° un usuario.")
                return
            r = (self.setrole_role.get() or "Empleado").strip()
            # normalizar a lo que entiende tu server (jefe/empleado)
            role_cmd = "Jefe" if r.lower().startswith("j") else "empleado"
            ok = _send_remote(f"setrole {u} {role_cmd}")
            if ok:
                messagebox.showinfo("OK", f"Comando enviado: setrole {u} {role_cmd}")

        ctk.CTkButton(
            r1, text="Aplicar", fg_color=TURQ, hover_color="#12b6aa",
            text_color="#062126", command=_apply_setrole
        ).pack(side="right", padx=12)

        # 2) A√±adir usuario
        r2 = ctk.CTkFrame(actions, fg_color=CARD2, corner_radius=14)
        r2.pack(fill="x", pady=8)
        ctk.CTkLabel(r2, text="A√±adir usuario", text_color=WHITE).pack(side="left", padx=12, pady=12)

        self.add_user = ctk.CTkEntry(r2, width=180, placeholder_text="Usuario")
        self.add_user.pack(side="left", padx=8)
        self.add_pass = ctk.CTkEntry(r2, width=180, placeholder_text="Contrase√±a", show="‚Ä¢")
        self.add_pass.pack(side="left", padx=8)

        def _apply_add():
            u = (self.add_user.get() or "").strip()
            p = (self.add_pass.get() or "").strip()
            if not u or not p:
                messagebox.showinfo("Info", "Usuario y contrase√±a requeridos.")
                return
            ok = _send_remote(f"add {u} {p}")
            if ok:
                messagebox.showinfo("OK", f"Comando enviado: add {u} *****")
                # refrescar lista si tu server lo soporta por 'list'
                _send_remote("list")

        ctk.CTkButton(
            r2, text="A√±adir", fg_color=TURQ, hover_color="#12b6aa",
            text_color="#062126", command=_apply_add
        ).pack(side="right", padx=12)

        # 3) Reset semanal countdown (solo UI)
        r3 = ctk.CTkFrame(actions, fg_color=CARD2, corner_radius=14)
        r3.pack(fill="x", pady=8)
        ctk.CTkLabel(r3, text="Reset semanal: s√°bado 00:00", text_color=WHITE).pack(side="left", padx=12, pady=12)

        self.lbl_countdown = ctk.CTkLabel(r3, text="Calculando‚Ä¶", text_color="#b8c4d0")
        self.lbl_countdown.pack(side="right", padx=12)

        # 4) Botones peligrosos
        r4 = ctk.CTkFrame(actions, fg_color="transparent")
        r4.pack(fill="x", pady=8)

        def _confirm_and_send(label, cmd, confirm_text):
            if not messagebox.askyesno("Confirmar", confirm_text):
                return
            ok = _send_remote(cmd)
            if ok:
                messagebox.showinfo("OK", f"Comando enviado: {label}")

        ctk.CTkButton(
            r4, text="Reset DB capturas", fg_color="#b23b3b", hover_color="#8f2e2e",
            command=lambda: _confirm_and_send("reset_capturas", "reset_capturas",
                                              "¬øResetear la DB/cach√© de capturas en el servidor?")
        ).pack(side="left", padx=6)

        ctk.CTkButton(
            r4, text="Reset historial", fg_color="#b23b3b", hover_color="#8f2e2e",
            command=lambda: _confirm_and_send("reset_historial", "reset_historial",
                                              "¬øResetear el historial en el servidor?")
        ).pack(side="left", padx=6)

        ctk.CTkButton(
            r4, text="Ejecutar reset semanal YA", fg_color="#b23b3b", hover_color="#8f2e2e",
            command=lambda: _confirm_and_send("reset_semanal", "reset_semanal", "¬øForzar el reset semanal ahora?")
        ).pack(side="left", padx=6)

        # ------------------------------------------------------------------
        # Arranques / refresh
        # ------------------------------------------------------------------
        _cancel_refresh()
        _cancel_countdown()

        # pedir stats del usuario del card al abrir
        try:
            u0 = (self.settings_user_var.get() or "").strip()
            if u0:
                self._request_user_stats(u0)
        except Exception:
            pass

        _refresh_user_card()
        _schedule_refresh()
        _start_countdown()

        # si vuelven a entrar a otra pesta√±a, cancelamos timers viejos
        try:
            # guardamos callbacks de limpieza para que _clear_main_holder los ejecute si existe
            self._settings_cleanup = lambda: (_cancel_refresh(), _cancel_countdown())
        except Exception:
            pass

    def _view_dashboard(self):
        self._clear_main_holder()

        # ====== Layout tipo screenshot: 2 columnas arriba + 2 cards abajo ======
        top_row = ctk.CTkFrame(self.main_holder, fg_color="transparent")
        top_row.pack(fill="both", expand=True, padx=16, pady=16)
        top_row.grid_columnconfigure(0, weight=1)
        top_row.grid_columnconfigure(1, weight=1)
        top_row.grid_rowconfigure(0, weight=1)
        top_row.grid_rowconfigure(1, weight=1)

        # --- Izquierda arriba: empleados ---
        box_left = ctk.CTkFrame(top_row, fg_color=CARD, corner_radius=18)
        box_left.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))

        # Panel mini-cards
        self.employees_panel = EmployeesPanel(box_left, on_select_user=self._on_select_employee)
        self.employees_panel.pack(fill="both", expand=True, padx=14, pady=14)

        # Bot√≥n actualizar -> refrescar ONLINE + historial (no pedir USER_LIST)
        self.employees_panel.set_refresh_command(self._refresh_online_and_history)

        # --- Derecha arriba: detalle empleado ---
        box_right = ctk.CTkFrame(top_row, fg_color=CARD, corner_radius=18)
        box_right.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))

        hdr = ctk.CTkFrame(box_right, fg_color="transparent")
        hdr.pack(fill="x", padx=14, pady=(14, 10))
        ctk.CTkLabel(hdr, text="Detalle de empleado", font=("Roboto", 14, "bold")).pack(side="left")

        self.selected_user_var = ctk.StringVar(value="Seleccionar empleado")
        self.user_menu = ctk.CTkOptionMenu(hdr, values=["Seleccionar empleado"], variable=self.selected_user_var,
                                           command=lambda v: self._on_select_employee(v))
        self.user_menu.pack(side="right")
        # ‚úÖ HISTORIAL dentro del bloque arriba derecha
        hist_card = ctk.CTkFrame(box_right, fg_color=CARD2, corner_radius=14)
        hist_card.pack(fill="both", expand=False, padx=14, pady=(0, 14))

        ctk.CTkLabel(
            hist_card,
            text="Historial (USER_STATS)",
            font=("Roboto", 12, "bold"),
            text_color=WHITE
        ).pack(anchor="w", padx=10, pady=(10, 6))

        self.history_box = ctk.CTkTextbox(
            hist_card,
            height=220,  # ‚úÖ m√°s grande
            fg_color="#0c1522",
            text_color=WHITE,
            font=("Consolas", 13),  # ‚úÖ texto m√°s grande
            wrap="word"
        )

        self.history_box.pack(fill="both", expand=True, padx=10, pady=(0, 10))

        self.history_box.insert("end", "‚Äî Historial listo ‚Äî\n")
        self.history_box.see("end")

        self.lbl_detail = ctk.CTkLabel(
            box_right,
            text="Seleccion√° un empleado para ver m√°s detalle.",
            text_color=MUTED,
            justify="left"
        )
        self.lbl_detail.pack(anchor="w", padx=14, pady=(0, 10))

        self.btn_capture = ctk.CTkButton(box_right, text="Capturar pantalla", width=180,
                                         command=self._capture_selected_user)
        self.btn_capture.pack(anchor="w", padx=14, pady=(0, 14))

        # ‚úÖ Bot√≥n Reconectar (solo habilitado si est√°s desconectado)
        self.btn_reconnect = ctk.CTkButton(
            box_right,
            text="üîå Reconectar",
            width=180,
            fg_color="#b23b3b",
            hover_color="#8f2e2e",
            command=self._manual_reconnect
        )
        # estado inicial
        self.btn_reconnect.configure(state=("disabled" if self.connected else "normal"))
        self.btn_reconnect.pack(anchor="w", padx=14, pady=(0, 14))

        # --- Abajo izquierda: preview captura ---
        box_bl = ctk.CTkFrame(top_row, fg_color=CARD, corner_radius=18)
        box_bl.grid(row=1, column=0, sticky="nsew", padx=(0, 10), pady=(10, 0))
        ctk.CTkLabel(box_bl, text="Captura (preview + zoom)", font=("Roboto", 12, "bold")).pack(
            anchor="w", padx=14, pady=(14, 8)
        )
        # --- Abajo izquierda: preview captura + editor ---
        box_bl = ctk.CTkFrame(top_row, fg_color=CARD, corner_radius=18)
        box_bl.grid(row=1, column=0, sticky="nsew", padx=(0, 10), pady=(10, 0))
        ctk.CTkLabel(box_bl, text="Captura (editor: zoom + subrayar)", font=("Roboto", 12, "bold")).pack(
            anchor="w", padx=14, pady=(14, 8)
        )

        # ‚úÖ Editor real
        self.preview_editor = ScreenshotEditor(box_bl, width=520, height=260)
        self.preview_editor.pack(fill="both", expand=True, padx=14, pady=(0, 14))

        # --- Abajo derecha: bloque extra ---
        # --- Abajo derecha: modo vigilancia ---
        box_br = ctk.CTkFrame(top_row, fg_color=CARD, corner_radius=18)
        box_br.grid(row=1, column=1, sticky="nsew", padx=(10, 0), pady=(10, 0))

        ctk.CTkLabel(box_br, text="Modo vigilancia", font=("Roboto", 12, "bold")).pack(
            anchor="w", padx=14, pady=(14, 8)
        )

        # status + countdown
        row_v1 = ctk.CTkFrame(box_br, fg_color="transparent")
        row_v1.pack(fill="x", padx=14, pady=(0, 8))

        self.vig_status_lbl = ctk.CTkLabel(row_v1, text="Estado: detenido", text_color=MUTED)
        self.vig_status_lbl.pack(side="left")

        self.vig_count_lbl = ctk.CTkLabel(row_v1, text="00:00", font=("Consolas", 14, "bold"), text_color=WHITE)
        self.vig_count_lbl.pack(side="right")

        # input minutos
        row_v2 = ctk.CTkFrame(box_br, fg_color="transparent")
        row_v2.pack(fill="x", padx=14, pady=(6, 10))

        ctk.CTkLabel(row_v2, text="Minutos:", text_color=MUTED).pack(side="left", padx=(0, 10))

        self.vig_entry = ctk.CTkEntry(row_v2, width=120, fg_color=CARD2, placeholder_text="ej: 15")
        self.vig_entry.pack(side="left")

        # bot√≥n iniciar/detener
        self.vig_btn = ctk.CTkButton(
            box_br,
            text="Iniciar",
            fg_color=OK,
            hover_color="#27ae60",
            command=self._toggle_vigilance
        )
        self.vig_btn.pack(anchor="w", padx=14, pady=(6, 14))

        # Al entrar al dashboard: pedir lista al server (si est√°s conectado)
        # ‚úÖ 1) pintar inmediatamente lo que haya en cache
        self.after(0, self._render_users_from_cache)

        # ‚úÖ 2) pedir lista real al server para refrescar
        self.after(200, self._request_user_list)

    def add_history(self, text: str):
        if not hasattr(self, "history_box") or not self.history_box:
            return
        try:
            self.history_box.insert("end", text + "\n")
            self.history_box.see("end")
        except:
            pass

    def _request_user_list(self):
        if not self.sock or not self.connected:
            return
        try:
            with self.socket_lock:
                self.sock.sendall(b"REQUEST_USER_LIST\n")
        except Exception as e:
            print("request_user_list error:", e)

    def _refresh_online_and_history(self):
        """Refresh del bot√≥n "Actualizar" del panel.

        El panel muestra estado ONLINE/OFFLINE + historial/log (viene por USER_STATS),
        as√≠ que este refresh fuerza la recarga de stats y repinta lo cacheado.
        """
        # 1) UI inmediata con cache
        try:
            self._render_users_from_cache()
        except Exception:
            pass

        if not getattr(self, "sock", None) or not getattr(self, "connected", False):
            return

        # 2) si hay un usuario seleccionado, prioridad para que el historial se actualice ya
        try:
            sel = (self.selected_user_var.get() or "").strip() if hasattr(self, "selected_user_var") else ""
            if sel and sel.lower() not in ("seleccionar empleado", "select user", "select"):
                self._request_user_stats(sel)
        except Exception:
            pass

        # 3) pedir stats de todos los usuarios cacheados (actualiza estados + historial)
        try:
            self.request_all_users_stats(delay_ms=120)
        except Exception:
            pass

        # 4) Se removieron comandos legacy no soportados por server para evitar ruido de protocolo.

    def _build_all_users_stats(self):
        latest = getattr(self, "_latest_stats", {}) or {}
        cached_users = getattr(self, "_cached_users", []) or []

        # Queremos mostrar TODOS los usuarios aunque a√∫n no tengan stats
        names = list(dict.fromkeys(cached_users + list(latest.keys())))

        out = []
        for name in names:
            info = latest.get(name, {}) or {}
            out.append({
                "name": name,
                "fg_time": info.get("fg_time", "0"),
                "bg_time": info.get("bg_time", "0"),
                "status": info.get("status", ""),
                "raw": info.get("raw", ""),
            })
        return out

    def _on_select_employee(self, username: str):
        username = (username or "").strip()
        if not username or username.lower() == "seleccionar empleado":
            return

        # UI: guardar selecci√≥n
        self.selected_user_var.set(username)

        # UI: feedback r√°pido (antes de que lleguen stats)
        if hasattr(self, "lbl_detail") and self.lbl_detail:
            self.lbl_detail.configure(text=f"Empleado: {username}\nCargando stats.")
        self._render_history_for_user(username, loading=True)

        # ‚úÖ SI est√° abierta la PerformanceView, sincronizarla con el usuario elegido
        try:
            if hasattr(self, "perf_view") and self.perf_view and self.perf_view.winfo_exists():
                self.perf_view.target_user = username

                # sincroniz√° tambi√©n el dropdown si existe
                try:
                    if hasattr(self.perf_view, "user_var") and self.perf_view.user_var:
                        self.perf_view.user_var.set(username)
                except:
                    pass

                # mostrale ‚Äúloading‚Äù para que no parezca que se qued√≥ pegado el usuario anterior
                try:
                    self.perf_view.set_loading(f"Cargando datos de {username}‚Ä¶")
                except:
                    pass
        except Exception as e:
            print("sync perf_view user error:", e)

        # ‚úÖ PEDIR STATS AL SERVER (UNA sola vez)
        self._request_user_stats(username)

    def _request_user_stats(self, user: str, day: str = None):
        if not user:
            return
        if not getattr(self, "sock", None) or not getattr(self, "connected", False):
            return
        # ‚úÖ siempre incluir fecha para que el server devuelva el d√≠a correcto
        if not day:
            day = date.today().isoformat()
        try:
            with self.socket_lock:
                self.sock.sendall(f"REQUEST_USER_STATS|{user}|{day}\n".encode("utf-8"))
                print(">>> SEND REQUEST_USER_STATS:", f"REQUEST_USER_STATS|{user}|{day}")
        except Exception as e:
            print("request_user_stats error:", e)

    def request_all_users_stats(self, day: str = None, delay_ms=180):
        """
        Pide stats de todos los usuarios conocidos (cacheados).
        Usa after() para no spamear el socket de golpe.
        Cancela barridos anteriores para no mezclar respuestas entre d√≠as.
        """
        if day is None:
            day = date.today().isoformat()
        users = list(getattr(self, "_cached_users", []) or [])
        if not users:
            print("request_all_users_stats: no hay _cached_users")
            return

        # placeholders para que existan aunque a√∫n no haya llegado nada
        if not hasattr(self, "_latest_stats") or self._latest_stats is None:
            self._latest_stats = {}
        for u in users:
            self._latest_stats.setdefault(u, {"fg_time": "0", "bg_time": "0", "status": "", "raw": ""})

        self._all_stats_req_gen += 1
        my_gen = self._all_stats_req_gen

        def _tick(i=0):
            if my_gen != self._all_stats_req_gen:
                return
            if i >= len(users):
                try:
                    if hasattr(self, "perf_view") and self.perf_view and self.perf_view.winfo_exists():
                        all_stats = self._build_all_users_stats()
                        self.perf_view.update_data(
                            all_users_stats=all_stats,
                            user_list=getattr(self, "_cached_users", []),
                        )
                except Exception as e:
                    print("request_all_users_stats refresh perf error:", e)
                return

            u = users[i]
            try:
                self._request_user_stats(u, day)
            except Exception as e:
                print("request_all_users_stats _request_user_stats error:", u, e)

            self.after(delay_ms, lambda: _tick(i + 1))

        _tick(0)

    def _build_all_users_stats(self):
        latest = getattr(self, "_latest_stats", {}) or {}
        cached_users = getattr(self, "_cached_users", []) or []
        names = list(dict.fromkeys(cached_users + list(latest.keys())))

        out = []
        for name in names:
            info = latest.get(name, {}) or {}
            out.append({
                "name": name,
                "fg_time": info.get("fg_time", "0"),
                "bg_time": info.get("bg_time", "0"),
                "status": info.get("status", ""),
                "raw": info.get("raw", ""),
            })
        return out

    def _capture_selected_user(self):
        user = (self.selected_user_var.get() or "").strip()
        if not user or user.lower() in ("seleccionar empleado", "select user", "select"):
            messagebox.showinfo("Info", "Primero seleccion√° un empleado.")
            return
        if not getattr(self, "sock", None):
            return

        tag = "MANUAL"  # o pon√© "BTN" si quer√©s distinguirlo

        try:
            # Us√° SIEMPRE el lock de env√≠o (uno solo para todo lo que se env√≠a por socket)
            lock = getattr(self, "send_lock", None) or getattr(self, "socket_lock", None)

            if lock:
                with lock:
                    self.sock.sendall(f"SEND_SCREENSHOT|{user}|{tag}\n".encode("utf-8"))
            else:
                # fallback si no ten√©s lock creado
                self.sock.sendall(f"SEND_SCREENSHOT|{user}|{tag}\n".encode("utf-8"))

        except Exception as e:
            messagebox.showerror("Error", f"No se pudo pedir captura: {e}")

    def _view_boss(self):
        self._clear_main_holder()

        # =========================================================
        # 0) Helpers locales (sin depender de otras partes)
        # =========================================================
        import os, json, threading
        from datetime import datetime, timedelta

        # --- estado GCAL en self (persistente entre vistas) ---
        if not hasattr(self, "_gc_service"):
            self._gc_service = None
        if not hasattr(self, "_gc_after_id"):
            self._gc_after_id = None
        if not hasattr(self, "_gcal_sent_state"):
            self._gcal_sent_state = {}
        if not hasattr(self, "_gcal_state_loaded_for"):
            self._gcal_state_loaded_for = None
        if not hasattr(self, "_gcal_force_full_sync_once"):
            self._gcal_force_full_sync_once = True

        if not hasattr(self, "_GCAL_LOG_LOCK"):
            self._GCAL_LOG_LOCK = threading.Lock()

        # --- rutas AppData (robustas) ---
        def _get_appdata_dir(app_name: str = "K-Client") -> str:
            base = os.getenv("APPDATA") or os.path.expanduser("~")
            p = os.path.join(base, app_name)
            os.makedirs(p, exist_ok=True)
            return p

        def _gcal_logs_dir() -> str:
            p = os.path.join(_get_appdata_dir("K-Client"), "gcal_logs")
            os.makedirs(p, exist_ok=True)
            return p

        def _gcal_state_path_for_user(user_id: str) -> str:
            return os.path.join(_gcal_logs_dir(), f"gcal_state_{user_id}.json")

        def _now_iso():
            return datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

        def _safe_json_min(obj) -> str:
            def default(o):
                return str(o)

            return json.dumps(obj, ensure_ascii=False, default=default, separators=(",", ":"))

        def _event_start_date_str(raw_event: dict) -> str:
            start = (raw_event or {}).get("start") or {}
            if start.get("date"):
                return str(start.get("date") or "")
            dt = start.get("dateTime") or ""
            return str(dt)[:10] if dt else ""

        def _gcal_make_dedupe_key(raw_event: dict) -> str:
            ev_id = (raw_event or {}).get("id", "") or ""
            start_date = _event_start_date_str(raw_event) or ""
            return f"{ev_id}|{start_date}"

        def _gcal_event_version(raw_event: dict) -> str:
            etag = (raw_event or {}).get("etag", "")
            upd = (raw_event or {}).get("updated", "")
            return etag or upd or ""

        def _gcal_load_sent_state(user_id: str):
            try:
                if not user_id:
                    return
                if self._gcal_state_loaded_for == user_id:
                    return
                fp = _gcal_state_path_for_user(user_id)
                if os.path.exists(fp):
                    with open(fp, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    self._gcal_sent_state = data if isinstance(data, dict) else {}
                else:
                    self._gcal_sent_state = {}
                self._gcal_state_loaded_for = user_id
            except Exception:
                self._gcal_sent_state = {}
                self._gcal_state_loaded_for = user_id

        def _gcal_save_sent_state(user_id: str):
            try:
                if not user_id:
                    return
                fp = _gcal_state_path_for_user(user_id)
                os.makedirs(os.path.dirname(fp) or ".", exist_ok=True)
                with open(fp, "w", encoding="utf-8") as f:
                    json.dump(self._gcal_sent_state, f, ensure_ascii=False, indent=2)
            except Exception:
                pass

        def _send_line(line: str):
            # usa tu m√©todo si existe
            try:
                fn = getattr(self, "_send_line", None)
                if callable(fn):
                    fn(line)
                    return
            except Exception:
                pass

            # fallback socket directo
            try:
                if not line.endswith("\n"):
                    line += "\n"
                s = getattr(self, "sock", None)
                if not s:
                    return
                lock = getattr(self, "socket_lock", None)
                if lock:
                    with lock:
                        s.sendall(line.encode("utf-8"))
                else:
                    s.sendall(line.encode("utf-8"))
            except Exception:
                pass

        # =========================================================
        # 1) UI base: role, users, theme, tabs (Tareas + Google)
        # =========================================================
        role = "boss" if (getattr(self, "current_role", "").lower() == "boss") else "employee"

        def _get_users():
            users = list(getattr(self, "_cached_users", []) or [])
            if not users and getattr(self, "current_user", ""):
                users = [self.current_user]
            return users

        tasks_context = {
            "role": role,
            "user_id": getattr(self, "current_user", "Jefe"),
            "can_edit_due": True if role == "boss" else False
        }

        theme = dict(DEFAULT_THEME)
        try:
            theme.update({
                "TURQ": TURQ,
                "NAVY": NAVY,
                "WHITE": WHITE,
                "CARD": CARD,
                "CARD2": CARD2,
                "MUTED": MUTED,
                "DANGER": DANGER,
                "OK": OK,
                "WARN": WARN,
            })
        except Exception:
            pass

        body = ctk.CTkFrame(self.main_holder, fg_color="transparent")
        body.pack(fill="both", expand=True, padx=16, pady=16)

        tabs = ctk.CTkTabview(
            body,
            fg_color="transparent",
            segmented_button_fg_color=theme.get("CARD", "#142235"),
            segmented_button_selected_color=theme.get("TURQ", "#19d3c5"),
            segmented_button_selected_hover_color="#12b5aa",
            segmented_button_unselected_color=theme.get("CARD2", "#101a2a"),
            segmented_button_unselected_hover_color="#1b2a42",
            text_color=theme.get("WHITE", "#ffffff")
        )
        tabs.pack(fill="both", expand=True)

        tab_tasks = tabs.add("Tareas")
        tab_gc = tabs.add("Google Calendar")

        # =========================================================
        # 2) Tab Tareas (igual que antes)
        # =========================================================
        self.tasks_module = TasksModule(
            tab_tasks,
            context=tasks_context,
            api=None,
            theme=theme,
            on_request_user_list=_get_users
        )
        self.tasks_module.pack(fill="both", expand=True, padx=0, pady=0)

        # =========================================================
        # 3) Google Calendar UI + Sync al server (igual l√≥gica que empleado)
        # =========================================================
        # refs UI (por si reabr√≠s vista)
        self.gc_status_lbl = None
        self.gc_next_run_lbl = None
        self.gc_client_text = None
        self.gc_events_scroll = None

        def _gc_update_status_ui(connected: bool):
            try:
                if self.gc_status_lbl and self.gc_status_lbl.winfo_exists():
                    self.gc_status_lbl.configure(
                        text=("Estado: Conectado" if connected else "Estado: Desconectado"),
                        text_color=(theme.get("OK", "#2ecc71") if connected else theme.get("DANGER", "#e74c3c"))
                    )
            except Exception:
                pass

        def _gc_cancel_schedule():
            try:
                if self._gc_after_id:
                    self.after_cancel(self._gc_after_id)
            except Exception:
                pass
            self._gc_after_id = None

        def _gc_clear_events():
            try:
                if self.gc_events_scroll and self.gc_events_scroll.winfo_exists():
                    for w in self.gc_events_scroll.winfo_children():
                        w.destroy()
            except Exception:
                pass

        def _gc_render_events(events):
            _gc_clear_events()

            if not events:
                ctk.CTkLabel(
                    self.gc_events_scroll,
                    text="No hay eventos esta semana.",
                    text_color=theme.get("MUTED", "#9aa7b3")
                ).pack(anchor="w", padx=10, pady=10)
                return

            for ev in events:
                title = (ev.get("summary") or "Sin t√≠tulo").strip()
                start = ev.get("start", {}).get("dateTime") or ev.get("start", {}).get("date") or ""
                end = ev.get("end", {}).get("dateTime") or ev.get("end", {}).get("date") or ""
                loc = (ev.get("location") or "").strip()

                card = ctk.CTkFrame(self.gc_events_scroll, fg_color=theme.get("CARD", "#142235"), corner_radius=14)
                card.pack(fill="x", padx=10, pady=8)

                ctk.CTkLabel(
                    card, text=title,
                    font=("Roboto", 13, "bold"),
                    text_color=theme.get("WHITE", "#ffffff")
                ).pack(anchor="w", padx=12, pady=(10, 2))

                meta = f"{start} ‚Üí {end}"
                if loc:
                    meta += f"   |   {loc}"

                ctk.CTkLabel(
                    card, text=meta,
                    font=("Roboto", 11),
                    text_color=theme.get("MUTED", "#9aa7b3")
                ).pack(anchor="w", padx=12, pady=(0, 10))

        def _gc_week_range_utc():
            # semana actual en UTC (lunes a lunes)
            from datetime import timezone
            now = datetime.now(timezone.utc)
            monday = (now.replace(hour=0, minute=0, second=0, microsecond=0) - timedelta(days=now.weekday()))
            next_monday = monday + timedelta(days=7)
            timeMin = monday.isoformat().replace("+00:00", "Z")
            timeMax = next_monday.isoformat().replace("+00:00", "Z")
            return timeMin, timeMax

        def _gc_load_service() -> bool:
            try:
                from google.oauth2.credentials import Credentials
                from google.auth.transport.requests import Request
                from googleapiclient.discovery import build

                scopes = ["https://www.googleapis.com/auth/calendar.readonly"]
                client_fp = os.path.join(_get_appdata_dir("K-Client"), "google_client.json")
                token_fp = os.path.join(_get_appdata_dir("K-Client"), "google_token.json")

                if not os.path.exists(client_fp):
                    self._gc_service = None
                    return False

                creds = None
                if os.path.exists(token_fp):
                    creds = Credentials.from_authorized_user_file(token_fp, scopes)

                if creds and creds.expired and creds.refresh_token:
                    creds.refresh(Request())
                    with open(token_fp, "w", encoding="utf-8") as f:
                        f.write(creds.to_json())

                if not creds or not creds.valid:
                    self._gc_service = None
                    return False

                self._gc_service = build("calendar", "v3", credentials=creds)
                return True
            except Exception:
                self._gc_service = None
                return False

        def _gc_connect_flow():
            # NO muestra errores (solo status)
            try:
                from google_auth_oauthlib.flow import InstalledAppFlow

                scopes = ["https://www.googleapis.com/auth/calendar.readonly"]
                client_fp = os.path.join(_get_appdata_dir("K-Client"), "google_client.json")
                token_fp = os.path.join(_get_appdata_dir("K-Client"), "google_token.json")

                if not os.path.exists(client_fp):
                    return

                flow = InstalledAppFlow.from_client_secrets_file(client_fp, scopes=scopes)
                creds = flow.run_local_server(port=0)

                with open(token_fp, "w", encoding="utf-8") as f:
                    f.write(creds.to_json())

                ok = _gc_load_service()
                _gc_update_status_ui(ok)
                if ok:
                    _gc_refresh_week_events()
                    _gc_schedule_hourly_at_minute_10()
            except Exception:
                _gc_update_status_ui(False)

        def _gc_disconnect():
            try:
                token_fp = os.path.join(_get_appdata_dir("K-Client"), "google_token.json")
                if os.path.exists(token_fp):
                    os.remove(token_fp)
            except Exception:
                pass
            self._gc_service = None
            _gc_update_status_ui(False)
            _gc_clear_events()
            _gc_cancel_schedule()

        def _gc_save_client_json_text():
            try:
                raw = (self.gc_client_text.get("0.0", "end") or "").strip()
            except Exception:
                raw = ""

            if not raw:
                return

            try:
                data = json.loads(raw)
                if not isinstance(data, dict):
                    return
                client_fp = os.path.join(_get_appdata_dir("K-Client"), "google_client.json")
                with open(client_fp, "w", encoding="utf-8") as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)

                ok = _gc_load_service()
                _gc_update_status_ui(ok)
            except Exception:
                pass

        def _gc_select_client_json_file():
            # si no hay filedialog en este m√≥dulo, no rompe
            try:
                from tkinter import filedialog
                fp = filedialog.askopenfilename(title="Seleccionar client_secret.json", filetypes=[("JSON", "*.json")])
                if not fp:
                    return
                with open(fp, "r", encoding="utf-8") as f:
                    data = json.load(f)
                client_fp = os.path.join(_get_appdata_dir("K-Client"), "google_client.json")
                with open(client_fp, "w", encoding="utf-8") as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)

                ok = _gc_load_service()
                _gc_update_status_ui(ok)
            except Exception:
                pass

        def _gcal_send_events_to_server(events: list, user_id: str):
            # 1) checks
            try:
                if not user_id:
                    return
                if not events:
                    return
                if not getattr(self, "sock", None):
                    # si tu boss no usa sock aqu√≠, no manda
                    return
            except Exception:
                return

            _gcal_load_sent_state(user_id)

            force_full = bool(getattr(self, "_gcal_force_full_sync_once", False))
            sent_any = False

            for ev in (events or []):
                if not isinstance(ev, dict):
                    continue

                key = _gcal_make_dedupe_key(ev)
                ver = _gcal_event_version(ev)

                if not force_full:
                    if key and ver and self._gcal_sent_state.get(key) == ver:
                        continue
                    if key and not ver and key in self._gcal_sent_state:
                        continue

                date_str = _event_start_date_str(ev) or ""
                payload = {
                    "source": "google_calendar",
                    "ts_saved_utc": _now_iso(),
                    "user_id": user_id,
                    "event": ev
                }
                payload_json = _safe_json_min(payload).replace("|", "\\u007c")

                line = "TASK_GOOGLE_CALENDAR2|" + user_id + "|" + date_str + "|" + payload_json
                _send_line(line)

                if key:
                    self._gcal_sent_state[key] = ver or "sent"
                    sent_any = True

            if sent_any:
                _gcal_save_sent_state(user_id)

            if force_full:
                self._gcal_force_full_sync_once = False

        def _gc_fetch_week_events():
            if not self._gc_service:
                return []
            timeMin, timeMax = _gc_week_range_utc()
            try:
                events_result = self._gc_service.events().list(
                    calendarId="primary",
                    timeMin=timeMin,
                    timeMax=timeMax,
                    singleEvents=True,
                    orderBy="startTime",
                    maxResults=250
                ).execute()
                return events_result.get("items", []) or []
            except Exception:
                return []

        def _gc_refresh_week_events():
            ok = _gc_load_service()
            _gc_update_status_ui(ok)
            if not ok:
                return

            events = _gc_fetch_week_events()
            _gc_render_events(events)

            # ‚úÖ mandar al server (boss tambi√©n)
            try:
                boss_user = getattr(self, "current_user", "") or "Jefe"
                _gcal_send_events_to_server(events, boss_user)
            except Exception:
                pass

        def _gc_schedule_hourly_at_minute_10():
            _gc_cancel_schedule()

            now = datetime.now()
            target = now.replace(minute=10, second=0, microsecond=0)
            if target <= now:
                target = target + timedelta(hours=1)

            ms = int((target - now).total_seconds() * 1000)

            def run_and_resched():
                _gc_refresh_week_events()
                _gc_schedule_hourly_at_minute_10()

            try:
                if self.gc_next_run_lbl and self.gc_next_run_lbl.winfo_exists():
                    self.gc_next_run_lbl.configure(text=f"Pr√≥xima actualizaci√≥n: {target.strftime('%H:%M')}")
            except Exception:
                pass

            try:
                self._gc_after_id = self.after(ms, run_and_resched)
            except Exception:
                self._gc_after_id = None

        # =========================================================
        # 4) Construcci√≥n UI Google Calendar (tab)
        # =========================================================
        gc_top = ctk.CTkFrame(tab_gc, fg_color="transparent")
        gc_top.pack(fill="x", padx=8, pady=(10, 8))

        self.gc_status_lbl = ctk.CTkLabel(
            gc_top, text="Estado: Desconectado",
            text_color=theme.get("DANGER", "#e74c3c"),
            font=("Roboto", 11)
        )
        self.gc_status_lbl.pack(side="left")

        self.gc_next_run_lbl = ctk.CTkLabel(
            gc_top, text="Pr√≥xima actualizaci√≥n: --:--",
            text_color=theme.get("MUTED", "#9aa7b3"),
            font=("Roboto", 11)
        )
        self.gc_next_run_lbl.pack(side="left", padx=(12, 0))

        btns = ctk.CTkFrame(gc_top, fg_color="transparent")
        btns.pack(side="right")

        ctk.CTkButton(
            btns, text="Seleccionar archivo", width=160,
            fg_color="#22324a", hover_color="#2b3e5b",
            command=_gc_select_client_json_file
        ).pack(side="left", padx=(0, 8))

        ctk.CTkButton(
            btns, text="Guardar JSON pegado", width=160,
            fg_color="#22324a", hover_color="#2b3e5b",
            command=_gc_save_client_json_text
        ).pack(side="left", padx=(0, 8))

        ctk.CTkButton(
            btns, text="Conectar", width=120,
            fg_color=theme.get("TURQ", "#19d3c5"),
            text_color="#001013", hover_color="#12b5aa",
            command=_gc_connect_flow
        ).pack(side="left", padx=(0, 8))

        ctk.CTkButton(
            btns, text="Desconectar", width=140,
            fg_color="#22324a", hover_color="#2b3e5b",
            command=_gc_disconnect
        ).pack(side="left")

        box = ctk.CTkFrame(tab_gc, fg_color=theme.get("CARD2", "#101a2a"), corner_radius=14)
        box.pack(fill="x", padx=8, pady=(0, 10))

        ctk.CTkLabel(
            box,
            text="Peg√° ac√° el JSON de credenciales (OAuth Desktop) si quer√©s:",
            text_color=theme.get("MUTED", "#9aa7b3"),
            font=("Roboto", 11)
        ).pack(anchor="w", padx=12, pady=(10, 6))

        self.gc_client_text = ctk.CTkTextbox(
            box, height=120,
            fg_color=theme.get("CARD", "#142235"),
            text_color=theme.get("WHITE", "#ffffff")
        )
        self.gc_client_text.pack(fill="x", padx=12, pady=(0, 12))

        self.gc_events_scroll = ctk.CTkScrollableFrame(tab_gc, fg_color="transparent")
        self.gc_events_scroll.pack(fill="both", expand=True, padx=8, pady=(0, 8))

        footer = ctk.CTkFrame(tab_gc, fg_color="transparent")
        footer.pack(fill="x", padx=8, pady=(0, 10))

        ctk.CTkButton(
            footer, text="Actualizar ahora", width=160,
            fg_color="#22324a", hover_color="#2b3e5b",
            command=_gc_refresh_week_events
        ).pack(side="left")

        # =========================================================
        # 5) Arranque: cargar servicio, refrescar, schedule, FULL sync 1 vez
        # =========================================================
        try:
            self._gcal_force_full_sync_once = True
            ok = _gc_load_service()
            _gc_update_status_ui(ok)
            if ok:
                _gc_refresh_week_events()
                _gc_schedule_hourly_at_minute_10()
            else:
                _gc_render_events([])
        except Exception:
            pass

        tabs.set("Tareas")

    def _open_console(self):
        self._clear_main_holder()
        if not self.sock:
            messagebox.showerror("Error", "No conectado.")
            return
        self.console_view = ConsoleWindow(self.main_holder, self.sock, self.socket_lock)
        self.console_view.pack(fill="both", expand=True)

    def _open_gallery(self):
        self._clear_main_holder()
        if not self.sock:
            messagebox.showerror("Error", "No conectado.")
            return
        self.gallery_view = ScreenshotGallery(self.main_holder, self.sock, self.socket_lock)
        self.gallery_view.pack(fill="both", expand=True)

        # ‚úÖ alias para compatibilidad con el c√≥digo viejo
        self.gallery_win = self.gallery_view

    # --- Dentro de la clase KClientApp ---

    def _open_performance(self):
        try:
            self._clear_main_holder()

            user = (self.selected_user_var.get() or "").strip()
            if not user or user.lower() == "seleccionar empleado":
                user = getattr(self, "current_user", "‚Äî")

            # 1. Crear la vista inmediatamente (VAC√çA pero con estructura)
            self.perf_view = PerfomanceView(
                self.main_holder,
                target_user=user,
                active_time_str="0h 0m",
                inactive_time_str="0h 0m",
                history_raw="",
                all_users_stats=self._build_all_users_stats(),
                user_list=getattr(self, "_cached_users", []),
                on_pick_user=self._perf_pick_user,
                on_refresh=self._trigger_refresh_perf,
                on_load_all=lambda d=None: self.request_all_users_stats(d),
            )
            self.perf_view.pack(fill="both", expand=True, padx=16, pady=16)

            # 2. Mostrar indicador de carga
            self.perf_view.set_loading(f"Solicitando datos de {user}...")

            # 3. Pedir los datos al servidor con un peque√±o delay para no bloquear el renderizado de la UI
            day_iso = date.today().isoformat()
            self.after(100, lambda: self._request_user_stats(user, day_iso))

        except Exception as e:
            print(f"Error abriendo Rendimiento: {e}")

    def _trigger_refresh_perf(self):
        """Refresco controlado para evitar desconexiones"""
        user = getattr(self.perf_view, "target_user", self.current_user)
        day = getattr(self.perf_view, "selected_day", date.today().isoformat())
        self.perf_view.set_loading("Actualizando...")
        self._request_user_stats(user, day)

    # --- Dentro de la clase PerfomanceView ---

    def _render_all_tabs(self):
        """Renderizado as√≠ncrono de pesta√±as para no congelar la UI"""

        def _step_render(steps):
            if not steps or not self.winfo_exists(): return
            tab_name, func = steps.pop(0)
            self._safe_setup(tab_name, func)
            # Programar la siguiente pesta√±a para el siguiente ciclo de la UI
            self.after(10, lambda: _step_render(steps))

        render_queue = [
            ("Actividad vs Inactividad", self.setup_pie_chart),
            ("Top 3 (FOCO)", self.setup_bar_chart),
            ("KPI (FOCO)", self.setup_quality_chart),
            ("Tabla Apps (FOCO)", self.setup_table_tab),
            ("Scoreboard Global", lambda: self.setup_scoreboard("active"))
        ]
        _step_render(render_queue)

    def _perf_pick_user(self, user: str, day: str = None):
        """
        Callback centralizado para cuando la PerformanceView pide datos
        de un usuario (con o sin fecha).
        """
        user = (user or "").strip()
        if not user:
            return
        if not day:
            # usar fecha seleccionada en la view si existe
            try:
                d = getattr(self.perf_view, "selected_day", None)
                if d:
                    day = d.isoformat() if hasattr(d, "isoformat") else str(d)
            except Exception:
                pass
        if not day:
            day = date.today().isoformat()
        self._request_user_stats(user, day)
    # ----------------------------
    # Send JSON helper (activity_v2)
    # ----------------------------
    def _send_json(self, payload: dict):
        if not self.sock:
            return
        try:
            data = json.dumps(payload, ensure_ascii=False).encode("utf-8")
            with self.socket_lock:
                self.sock.sendall(b"JSON|" + data + b"\n")
        except Exception as e:
            print("send_json error:", e)

    def _request_ai_log_from_server(self, user: str, day: str, max_lines: int = 300):
        try:
            if not self.connected or not self.sock:
                return
            user = (user or "").strip()
            day = (day or "").strip()
            if not user:
                return
            if not day:
                day = datetime.now().strftime("%Y-%m-%d")
            if not isinstance(max_lines, int) or max_lines <= 0:
                max_lines = 300

            msg = f"AI_LOG_REQ|{user}|{day}|{max_lines}\n"
            with self.socket_lock:
                try:
                    self.sock.sendall(msg.encode("utf-8"))
                except:
                    pass
        except Exception as e:
            print("_request_ai_log_from_server error:", e)

    def _load_users_cache(self) -> dict:
        p = users_cache_path()
        if not os.path.exists(p):
            return {"users": [], "status": {}, "last_update": 0}
        try:
            with open(p, "r", encoding="utf-8") as f:
                data = json.load(f)
            if not isinstance(data, dict):
                return {"users": [], "status": {}, "last_update": 0}
            data.setdefault("users", [])
            data.setdefault("status", {})
            data.setdefault("last_update", 0)
            return data
        except Exception:
            return {"users": [], "status": {}, "last_update": 0}

    def _save_users_cache(self, data: dict):
        try:
            data = data or {}
            data.setdefault("users", [])
            data.setdefault("status", {})
            data["last_update"] = int(time.time())
            p = users_cache_path()
            tmp = p + ".part"
            with open(tmp, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            os.replace(tmp, p)
        except Exception:
            pass

    def _cache_set_users(self, users: List[str]):
        users = [u.strip() for u in (users or []) if u and u.strip()]
        data = self._load_users_cache()

        # ‚úÖ mantener tambi√©n en memoria para la UI (settings / dropdowns)
        try:
            self._cached_users = list(users)
        except Exception:
            pass

        # mantener status existentes, limpiar los que ya no est√°n
        st = data.get("status", {}) or {}
        alive = set(u.lower() for u in users)
        st = {k: v for k, v in st.items() if k.lower() in alive}

        data["users"] = users
        data["status"] = st
        self._save_users_cache(data)

    def _cache_set_status(self, user: str, status_text: str, color: str = None):
        user = (user or "").strip()
        if not user:
            return
        data = self._load_users_cache()
        st = data.get("status", {}) or {}

        st[user] = {
            "text": status_text or "‚Äî",
            "color": color or ""
        }
        data["status"] = st

        # si no est√° en users, lo agregamos (por si llega stats antes que list)
        users = data.get("users", []) or []
        if user not in users:
            users.append(user)
            data["users"] = users

        self._save_users_cache(data)

    def _render_users_from_cache(self):
        """
        Repinta EmployeesPanel + OptionMenu desde el JSON cache.
        Llamalo al entrar al Dashboard o al volver de otra tab.
        """
        data = self._load_users_cache()
        users = data.get("users", []) or []
        status_map = data.get("status", {}) or {}

        # 1) panel de cards
        if hasattr(self, "employees_panel") and self.employees_panel and self.employees_panel.winfo_exists():
            self.employees_panel.update_users(users)
            # pintar estados si existen
            for u in users:
                info = status_map.get(u) or {}
                txt = info.get("text") or "‚Äî"
                col = info.get("color") or MUTED
                if txt != "‚Äî":
                    self.employees_panel.set_user_status(u, txt, color=col)

        # 2) option menu
        if hasattr(self, "user_menu") and self.user_menu and self.user_menu.winfo_exists():
            values = ["Seleccionar empleado"] + users
            self.user_menu.configure(values=values)

            cur = (self.selected_user_var.get() or "").strip()
            if cur and cur != "Seleccionar empleado" and cur in users:
                self.selected_user_var.set(cur)
            else:
                self.selected_user_var.set("Seleccionar empleado")

    def _handle_ai_log_bytes(self, user: str, day: str, data: bytes):
        try:
            txt = data.decode("utf-8", errors="ignore")
        except:
            txt = ""

        # actualizar PerformanceView si existe
        try:
            if hasattr(self, "perf_view") and self.perf_view and self.perf_view.winfo_exists():
                self.after(0, lambda: self.perf_view.set_ai_log_text(user, day, txt))
        except Exception as e:
            print("_handle_ai_log_bytes ui error:", e)

        # opcional: tambi√©n mandar a consola
        try:
            if self.console_win and self.console_win.winfo_exists():
                self.console_win.add_output(f"\n[AI LOG] {user} {day}\n")
        except:
            pass

    # ----------------------------
    # Listen loop (server -> UI)
    # ----------------------------
    def _listen_loop(self):
        """
        Soporta:
          - L√≠neas de texto terminadas en \n (SCREENSHOT_LIST|..., SHOW_POPUP|..., etc)
          - Binario: PHOTO_DATA|fname|size\n<bytes...>
        """
        buf = b""
        expecting = None  # None o dict: {"fname": str, "remaining": int}

        while self.connected and self.sock:
            try:
                chunk = self.sock.recv(4096)
                if not chunk:
                    break
                buf += chunk

                while True:
                    # 1) Si estamos esperando binario de una foto, consumir bytes
                    if expecting is not None:
                        need = expecting["remaining"]
                        if len(buf) < need:
                            # todav√≠a no lleg√≥ todo
                            break

                        data = buf[:need]
                        buf = buf[need:]
                        etype = expecting.get("type")
                        fname = expecting.get("fname", "")
                        meta = expecting.get("meta", {})
                        expecting = None

                        if etype == "photo":
                            self._handle_photo_data_bytes(fname, data)
                        elif etype == "ai_log":
                            self._handle_ai_log_bytes(meta.get("user", ""), meta.get("day", ""), data)
                        else:
                            # fallback
                            try:
                                self._handle_photo_data_bytes(fname, data)
                            except:
                                pass

                        # seguir el loop: puede haber otra l√≠nea o m√°s binario en buf
                        continue

                    # 2) No estamos esperando binario: buscar una l√≠nea completa
                    if b"\n" not in buf:
                        break

                    line, buf = buf.split(b"\n", 1)
                    line_str = line.decode("utf-8", errors="ignore").strip()
                    if not line_str:
                        continue

                    # 3) Header especial de binario
                    # Formato: PHOTO_DATA|fname|size
                    print(line_str)
                    # ‚úÖ Respuesta de chat IA (texto)
                    if line_str.startswith("AI_CHAT_RESP|"):
                        try:
                            self._handle_ai_chat_resp_line(line_str)
                        except Exception as e:
                            print("AI_CHAT_RESP error:", e)
                        continue

                    if line_str.startswith("PHOTO_DATA|"):
                        parts = line_str.split("|")
                        if len(parts) >= 3:
                            fname = parts[1].strip()
                            try:
                                size = int(parts[2].strip())
                            except:
                                size = 0

                            if size <= 0 or not fname:
                                print("PHOTO_DATA header inv√°lido:", line_str)
                                continue

                            expecting = {"fname": fname, "remaining": size}
                            # volver arriba: si ya hay bytes en buf, los consume en el mismo ciclo
                            continue
                        else:
                            print("PHOTO_DATA header incompleto:", line_str)
                            continue
                    if line_str.startswith("AI_LOG_DATA|"):
                        parts = line_str.split("|")
                        # AI_LOG_DATA|user|day|size
                        if len(parts) >= 4:
                            u = parts[1].strip()
                            day = parts[2].strip()
                            try:
                                size = int(parts[3].strip())
                            except:
                                size = 0

                            if size <= 0:
                                print("AI_LOG_DATA header inv√°lido:", line_str)
                                continue

                            expecting = {
                                "type": "ai_log",
                                "remaining": size,
                                "meta": {"user": u, "day": day}
                            }
                            continue
                        else:
                            print("AI_LOG_DATA header incompleto:", line_str)
                            continue

                    # 4) L√≠nea normal de texto
                    self.handle_line(line_str)

            except Exception as e:
                print("listen_loop:", e)
                break

        self.connected = False
        # cerrar socket y actualizar UI
        try:
            if getattr(self, "sock", None):
                with self.socket_lock:
                    try:
                        self.sock.close()
                    except Exception:
                        pass
        except Exception:
            pass
        self.sock = None
        try:
            self._set_connection_state(False)
        except Exception:
            pass

        # aviso (una sola vez por ca√≠da)
        try:
            if not getattr(self, "_reconnect_in_progress", False):
                self.after(0, lambda: messagebox.showwarning("Desconectado", "Se perdi√≥ la conexi√≥n con el servidor."))
        except Exception:
            pass
        try:
            self._flush_user_stats_block()
        except:
            pass

    def _handle_photo_data_bytes(self, fname: str, data: bytes):
        """
        Guarda el archivo en cache_capturas y refresca la galer√≠a si est√° abierta.
        """
        try:
            cache_dir = get_cache_dir()
            os.makedirs(cache_dir, exist_ok=True)

            # seguridad m√≠nima del nombre
            safe = os.path.basename(fname).replace("\\", "_").replace("/", "_").strip()
            if not safe:
                return

            out_path = os.path.join(cache_dir, safe)

            # escribir atomic-ish: primero .part y luego rename
            tmp_path = out_path + ".part"
            with open(tmp_path, "wb") as f:
                f.write(data)
                f.flush()
                try:
                    os.fsync(f.fileno())
                except:
                    pass

            try:
                os.replace(tmp_path, out_path)
            except:
                # fallback
                shutil.move(tmp_path, out_path)

            # refrescar UI (si la galer√≠a est√° abierta)
            if self.gallery_win and self.gallery_win.winfo_exists():
                self.after(0, self.gallery_win.load_local_filenames)

            # ‚úÖ NUEVO: mostrar la √∫ltima captura en el bloque abajo izquierda
            try:
                if hasattr(self, "preview_editor") and self.preview_editor and self.preview_editor.winfo_exists():
                    self.after(0, lambda p=out_path: self.preview_editor.load_image_path(p))
            except Exception:
                pass

        except Exception as e:
            print("_handle_photo_data_bytes:", e)

    def handle_line(self, line: str):
        line = (line or "").rstrip("\n")


        # ‚úÖ Caso raro: el servidor a veces manda las l√≠neas de detalle ANTES del header USER_STATS|
        # Las guardamos para adjuntarlas cuando llegue la cabecera.
        if (not self._stats_block_active) and (
                line.startswith(">")
                or line.startswith("TOP ")
                or line.startswith("ACTIVE>")
                or line.startswith("----------------")
        ):
            self._pre_stats_lines.append(line)
            return

        # ‚úÖ Si estamos acumulando USER_STATS, seguimos juntando l√≠neas hasta que aparezca otra cabecera
        if self._stats_block_active:
            if self._is_header_line(line):
                # termin√≥ el bloque anterior
                self._flush_user_stats_block()
                # y seguimos procesando esta l√≠nea como nueva cabecera (no return)
            else:
                self._stats_block_lines.append(line)
                return


        # ‚úÖ Detectar inicio de bloque USER_STATS
        if line.startswith("USER_STATS|"):
            # Si llega un nuevo header y hab√≠a bloque pendiente, flush inmediato del anterior
            if self._stats_block_active:
                try:
                    self._flush_user_stats_block()
                except Exception:
                    pass

            parts = line.split("|")
            # Formato: USER_STATS|user|date|status|active|inactive|history_escaped
            if len(parts) >= 6:
                user = parts[1].strip()
                req_date = parts[2].strip()
                status = parts[3].strip()
                fg_time = parts[4].strip()
                bg_time = parts[5].strip()
                history_raw = parts[6].replace("\\n", "\n") if len(parts) > 6 else ""

                # preparar bloque (soporta payload en 1 l√≠nea o multiline en l√≠neas siguientes)
                self._stats_block_active = True
                self._stats_block_user = user
                self._stats_block_status = status
                self._stats_block_fg_time = fg_time
                self._stats_block_bg_time = bg_time
                self._stats_block_date = req_date
                self._stats_block_lines = [history_raw] if history_raw else []

                # UI r√°pida de estado (card + detalle)
                if hasattr(self, "employees_panel") and self.employees_panel and self.employees_panel.winfo_exists():
                    color = OK if status == "ONLINE" else DANGER
                    self.employees_panel.set_user_status(user, status, color=color)

                if self.selected_user_var.get() == user:
                    try:
                        self.lbl_detail.configure(text=f"Empleado: {user} | Fecha: {req_date}\nEstado: {status}")
                    except Exception:
                        pass

                # flush diferido: captura multiline, pero tambi√©n cierra casos de una sola l√≠nea
                try:
                    if getattr(self, "_stats_flush_after_id", None):
                        self.after_cancel(self._stats_flush_after_id)
                except Exception:
                    pass
                self._stats_flush_after_id = self.after(120, self._flush_user_stats_block)

            return

        if line.startswith("USER_LIST|"):
            raw = line.split("|", 1)[1] if "|" in line else ""
            users = [x.strip() for x in raw.split(",") if x.strip()]

            # cachear siempre
            self._cache_set_users(users)
            # ‚úÖ crear placeholders en latest_stats para que el scoreboard liste a todos
            if not hasattr(self, "_latest_stats"):
                self._latest_stats = {}
            for u in users:
                self._latest_stats.setdefault(u, {"fg_time": "0", "bg_time": "0", "status": "", "raw": ""})

            def ui_update():
                if hasattr(self, "employees_panel") and self.employees_panel and self.employees_panel.winfo_exists():
                    self.employees_panel.update_users(users)

                if hasattr(self, "user_menu") and self.user_menu and self.user_menu.winfo_exists():
                    values = ["Seleccionar empleado"] + users
                    self.user_menu.configure(values=values)
                    cur = (self.selected_user_var.get() or "").strip()
                    if cur not in users:
                        self.selected_user_var.set("Seleccionar empleado")

                # ‚úÖ actualizar perf SIEMPRE que est√© abierta
                if hasattr(self, "perf_view") and self.perf_view and self.perf_view.winfo_exists():
                    self.perf_view.set_users(users)

            self.after(0, ui_update)

            # refrescar estados: si lista cambia, o si todav√≠a hay usuarios sin estado cargado
            has_missing_status = any(not (self._latest_stats.get(u, {}) or {}).get("status") for u in users)
            if has_missing_status or (not self._should_ignore_duplicate_user_list(users)):
                self._start_auto_stats_refresh(users)

            return

        if line == "PONG":
            return

        if line.startswith("CONSOLE_OUTPUT|"):
            txt = line.split("|", 1)[1] + "\n"
            if self.console_win and self.console_win.winfo_exists():
                self.console_win.add_output(txt)
            return

        if line.startswith("SHOW_POPUP|"):
            parts = line.split("|", 2)
            title = parts[1] if len(parts) > 1 else "Info"
            msg = parts[2] if len(parts) > 2 else ""
            self.after(0, lambda: messagebox.showinfo(title, msg))
            return
        if line.startswith("TAKE_SCREENSHOT|"):
            # Server manda:
            # TAKE_SCREENSHOT|TAG
            # TAKE_SCREENSHOT|TAG|TARGETUSER
            parts = line.split("|")

            tag = "MANUAL"
            target_user = None

            if len(parts) >= 2 and parts[1].strip():
                tag = parts[1].strip()

            if len(parts) >= 3 and parts[2].strip():
                target_user = parts[2].strip()

            threading.Thread(
                target=self._take_and_send_screenshot,
                args=(tag, target_user),
                daemon=True
            ).start()
            return

        if line.startswith("SCREENSHOT_LIST|"):
            raw = line.split("|", 1)[1] if "|" in line else ""
            files = [x.strip() for x in raw.split(",") if x.strip()]

            if self.gallery_win and self.gallery_win.winfo_exists():
                self.gallery_win.update_and_sync(files)
            return

        # (Ac√° pod√©s meter USER_LIST / USER_STATS como ya ten√≠as)
        # print("SERVER:", line)

    # ----------------------------
    # Monitor loop (FG/BG)
    # ----------------------------
    def _monitor_loop(self):
        # Reusa tu l√≥gica real con pygetwindow si la ten√≠as.
        try:
            import pygetwindow as gw
        except Exception:
            gw = None

        while True:
            time.sleep(1.0)
            if not self.connected or not self.activity_tracker:
                continue

            fg_title = ""
            others = []

            try:
                if gw:
                    win = gw.getActiveWindow()
                    fg_title = win.title if win else ""
                    # otras ventanas (best-effort)
                    titles = []
                    for w in gw.getAllWindows():
                        try:
                            if w and w.title:
                                titles.append(w.title)
                        except:
                            pass
                    others = titles[:25]
            except:
                pass

            try:
                self.activity_tracker.tick(fg_title, others)
            except:
                pass

    def _on_close(self):
        # Evitar doble cierre
        if getattr(self, "_closing", False):
            return
        self._closing = True

        # 1) cortar loops after (todos los que existan)
        for attr in (
                "_reconnect_after_id",
                "_settings_after_id",
                "_settings_count_after",
                "_dashboard_after_id",
                "_ui_pump_after_id",
        ):
            try:
                aid = getattr(self, attr, None)
                if aid:
                    self.after_cancel(aid)
            except Exception:
                pass
            try:
                setattr(self, attr, None)
            except Exception:
                pass

        # 2) avisar a threads que paren
        try:
            self.connected = False
        except Exception:
            pass

        # 3) cerrar socket y desbloquear recv()
        try:
            if getattr(self, "sock", None):
                try:
                    self.sock.shutdown(2)  # SHUT_RDWR
                except Exception:
                    pass
                try:
                    self.sock.close()
                except Exception:
                    pass
        except Exception:
            pass
        self.sock = None

        # 4) cerrar ventanas hijas si existen
        for w_attr in ("perf_win", "gallery_win"):
            try:
                w = getattr(self, w_attr, None)
                if w is not None and w.winfo_exists():
                    w.destroy()
            except Exception:
                pass

        # 5) destruir la app
        try:
            # cortar mainloop si est√° corriendo
            try:
                self.quit()
            except Exception:
                pass
            self.destroy()
        except Exception:
            pass

        # Con protocol("WM_DELETE_WINDOW", self._on_close) + threads daemon,
        # el proceso deber√≠a terminar al cerrar la ventana.


# ======================================================================
# RUN
# ======================================================================

if __name__ == "__main__":
    app = KClientApp()
    app.mainloop()

